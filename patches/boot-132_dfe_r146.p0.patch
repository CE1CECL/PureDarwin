Index: i386/libsaio/fake_efi.h
===================================================================
--- i386/libsaio/fake_efi.h	(.../vendor/132)	(revision 0)
+++ i386/libsaio/fake_efi.h	(.../branches/public)	(revision 146)
@@ -0,0 +1,11 @@
+/*
+ * Copyright 2007 David F. Elliott.  All rights reserved.
+ */
+
+#ifndef __LIBSAIO_FAKE_EFI_H
+#define __LIBSAIO_FAKE_EFI_H
+
+extern void
+setupFakeEfi(void);
+
+#endif /* !__LIBSAIO_FAKE_EFI_H */
Index: i386/libsaio/asm.s
===================================================================
--- i386/libsaio/asm.s	(.../vendor/132)	(revision 146)
+++ i386/libsaio/asm.s	(.../branches/public)	(revision 146)
@@ -130,7 +130,11 @@
     .file "asm.s"
 
 CR0_PE_ON  = 0x1
+#ifdef BOOT1
+CR0_PE_OFF = 0x7ffffffe
+#else
 CR0_PE_OFF = 0x7ffffff0
+#endif
 
 STACK32_BASE = ADDR32(STACK_SEG, 0)
 STACK16_SEG  = STACK_SEG
@@ -151,6 +155,27 @@
     .long vtop(_Gdt)
 
 // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+// IDTR representing real-mode IVT.  The values are constant.
+    .const
+// Real mode IDT
+    .align 2
+.globl _Idtr_real
+_Idtr_real:
+    .word  0x03ff
+    .long 0x00000000
+
+// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+// IDTR representing protected-mode IDT.  It is initially NULL which tells the
+// procesor that no IDT is available.  After we get into protected mode we can
+// allocate memory for a proper IDT and update this IDTR to point to it.
+    .data
+    .align 2
+.globl _Idtr_prot
+_Idtr_prot:
+    .word 0
+    .long 0
+
+// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 // Data area for __switch_stack.
 //
 save_sp: .long  STACK_OFS
@@ -200,6 +225,9 @@
     movw    %ax, %fs
     movw    %ax, %gs
 
+    // set up the PM IDT
+    lidt _Idtr_prot
+
     // Convert STACK_SEG:SP to 32-bit linear stack pointer.
 
     movzwl  %sp, %eax
@@ -229,6 +257,10 @@
 // 
 LABEL(__prot_to_real)
 
+    // Load real-mode IDT while we're still in USE32 mode so we don't need
+    // 32-bit addressing prefixes.
+    lidt _Idtr_real
+
     // Set up segment registers appropriate for real mode.
 
     movw    $0x30, %ax
@@ -296,9 +328,14 @@
 // halt()
 //
 LABEL(_halt)
+#ifdef BOOT1
+    hlt
+#else
     call    _bgetc
+#endif
     jmp     _halt
 
+#ifndef BOOT1
 // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 // startprog(phyaddr, arg)
 // Start the program on protected mode where phyaddr is the entry point.
@@ -321,6 +358,7 @@
     movw    %bx, %es
 
     lret
+#endif
 
 // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 // Returns the current stack pointer.
@@ -376,6 +414,7 @@
 
     ret
 
+#ifndef BOOT1
 // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 // loader()
 //
@@ -416,6 +455,7 @@
     popal
     leave
     ret
+#endif
 
 #if UNUSED
 // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Index: i386/libsaio/console.c
===================================================================
--- i386/libsaio/console.c	(.../vendor/132)	(revision 146)
+++ i386/libsaio/console.c	(.../branches/public)	(revision 146)
@@ -96,7 +96,7 @@
 int printf(const char * fmt, ...)
 {
     va_list ap;
-    if (bootArgs->Video.v_display != VGA_TEXT_MODE) return -1;
+    if ((bootArgs != NULL) && (bootArgs->Video.v_display != VGA_TEXT_MODE)) return -1;
     va_start(ap, fmt);
     prf(fmt, ap, putchar, 0);
     va_end(ap);
Index: i386/libsaio/fdisk.h
===================================================================
--- i386/libsaio/fdisk.h	(.../vendor/132)	(revision 146)
+++ i386/libsaio/fdisk.h	(.../branches/public)	(revision 146)
@@ -66,7 +66,7 @@
     unsigned char    endcyl;    /* High 2 bits are in endsect */
     unsigned long    relsect;   /* partion physical offset on disk */
     unsigned long    numsect;   /* number of sectors in partition */
-};
+} __attribute__((packed));
 
 /*
  * Format of boot block.
@@ -77,4 +77,10 @@
     unsigned short   signature;
 };
 
+struct REAL_disk_blk0 {
+    unsigned char    bootcode[DISK_BOOTSZ];
+    struct fdisk_part    parts[FDISK_NPART];
+    unsigned short   signature;
+} __attribute__((packed));
+
 #endif /* !__LIBSAIO_FDISK_H */
Index: i386/libsaio/bootstruct.c
===================================================================
--- i386/libsaio/bootstruct.c	(.../vendor/132)	(revision 146)
+++ i386/libsaio/bootstruct.c	(.../branches/public)	(revision 146)
@@ -40,7 +40,7 @@
 
 static char platformName[64];
 
-void initKernBootStruct( int biosdev )
+void initKernBootStruct( void )
 {
     Node *node;
     int nameLen;
@@ -96,9 +96,6 @@
         init_done = 1;
     }
 
-    // Update kernDev from biosdev.
-
-    bootInfo->kernDev = biosdev;
 }
 
 
Index: i386/libsaio/ntfs.c
===================================================================
--- i386/libsaio/ntfs.c	(.../vendor/132)	(revision 146)
+++ i386/libsaio/ntfs.c	(.../branches/public)	(revision 146)
@@ -140,16 +140,6 @@
     return 1;	/* No matching attrType found */
 }
 
-static int
-memcmp(const char *p1, const char *p2, int len)
-{
-    while (len--) {
-        if (*p1++ != *p2++)
-            return -1;
-    }
-    return 0;
-}
-
 /*
  * Examine a volume to see if we recognize it as a mountable.
  */
Index: i386/libsaio/hfs_CaseTables.h
===================================================================
--- i386/libsaio/hfs_CaseTables.h	(.../vendor/132)	(revision 146)
+++ i386/libsaio/hfs_CaseTables.h	(.../branches/public)	(revision 146)
@@ -473,7 +473,12 @@
  {0x1, 0x1a, 0xff41}, 
  {0x1, 0xc5, 0xff3b}, 
 };
-#define kLowerCaseTableNBlocks 182
+// Please update count if you add/remove entries but also please just let
+// the compiler calculate it so you don't get it wrong.
+//#define kLowerCaseTableNBlocks 182
+#define kLowerCaseTableNBlocks (sizeof(gLowerCaseTableCompressed)/sizeof(*gLowerCaseTableCompressed))
+// WARNING: The expanded size MUST be updated if you change the table and
+// cannot be calculated at compile time.
 #define kLowerCaseTableDataSize 5632 /* size of uncompressed structure in bytes */
 
 unsigned short *gCompareTable;
@@ -544,7 +549,12 @@
  {0x0, 0x1, 0x5988}, 
  {0x2, 0x27, 0xd900}, 
 };
-#define kCompareTableNBlocks 255
+// Please update count if you add/remove entries but also please just let
+// the compiler calculate it so you don't get it wrong.
+//#define kCompareTableNBlocks 64
+#define kCompareTableNBlocks (sizeof(gCompareTableCompressed)/sizeof(*gCompareTableCompressed))
+// WARNING: The expanded size MUST be updated if you change the table and
+// cannot be calculated at compile time.
 #define kCompareTableDataSize 512 /* size of uncompressed structure in bytes */
 
 #endif /* UNCOMPRESSED */
Index: i386/libsaio/bootstruct.h
===================================================================
--- i386/libsaio/bootstruct.h	(.../vendor/132)	(revision 146)
+++ i386/libsaio/bootstruct.h	(.../branches/public)	(revision 146)
@@ -30,6 +30,9 @@
 #include "bios.h"
 #include "device_tree.h"
 
+/*!
+    Kernel boot args global also used by booter for its own data.
+ */
 extern boot_args *bootArgs;
 extern Node *gMemoryMapNode;
 
@@ -87,12 +90,20 @@
     /* Undefined types should be treated as kMemoryRangeReserved */
 };
 
+/*!
+    PrivateBootInfo has fields used by the booter that used to be part of
+    KernelBootArgs_t *bootArgs.  When the switch was made to EFI the structure
+    completely changed to boot_args *bootArgs.  This (new to boot-132) structure
+    contains the fields the kernel no longer cares about but the booter still
+    uses internally.  Some fields (e.g. the video information) remain interesting
+    to the kernel and are thus located in bootArgs although with different field names.
+ */
 typedef struct PrivateBootInfo {
-    int              kernDev;                      // device kernel was fetched from
-
     int              convmem;                      // conventional memory
     int              extmem;                       // extended memory
+#if 0
     int              numBootDrivers;               // number of drivers loaded
+#endif
     char             bootFile[128];                // kernel file name
 
     unsigned long    memoryMapCount;
@@ -100,7 +111,9 @@
 
     PCI_bus_info_t   pciInfo;
 
+#if 0
     driver_config_t  driverConfig[NDRIVERS];
+#endif
     char *           configEnd;                    // pointer to end of config files
     char             config[CONFIG_SIZE];
 } PrivateBootInfo_t;
Index: i386/libsaio/sys.c
===================================================================
--- i386/libsaio/sys.c	(.../vendor/132)	(revision 146)
+++ i386/libsaio/sys.c	(.../branches/public)	(revision 146)
@@ -54,15 +54,31 @@
  *	@(#)sys.c	7.1 (Berkeley) 6/5/86
  */
 
+/*  Copyright 2007 VMware Inc.
+    "Preboot" ramdisk support added by David Elliott
+ */
+
+#include <AvailabilityMacros.h>
+
 #include "libsaio.h"
 #include "bootstruct.h"
-#include <sys/md5.h>
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5
+# include <Kernel/libkern/crypto/md5.h>
+#else
+# include <sys/md5.h>
+#endif
 #include <uuid/uuid.h>
+#if 0 /* No OS X release has ever included this. */
 #include <Kernel/uuid/namespace.h>
+#else
+/* copied from uuid/namespace.h, just like BootX's fs.c does. */
+UUID_DEFINE( kFSUUIDNamespaceSHA1, 0xB3, 0xE2, 0x0F, 0x39, 0xF2, 0x92, 0x11, 0xD6, 0x97, 0xA4, 0x00, 0x30, 0x65, 0x43, 0xEC, 0xAC );
+#endif
 
 struct devsw {
     const char *  name;
-    unsigned char biosdev;
+    // size increased from char to short to handle non-BIOS internal devices
+    unsigned short biosdev;
     int type;
 };
 
@@ -72,6 +88,7 @@
     { "hd", 0x80, kBIOSDevTypeHardDrive },  /* DEV_HD */
     { "fd", 0x00, kBIOSDevTypeFloppy    },  /* DEV_FD */
     { "en", 0xE0, kBIOSDevTypeNetwork   },  /* DEV_EN */
+    { "rd", 0x100, kBIOSDevTypeHardDrive },
     { 0, 0 }
 };
 
@@ -610,31 +627,6 @@
 
 //==========================================================================
 
-int currentdev()
-{
-    printf("currentdev = %d\n", bootInfo->kernDev);
-    return bootInfo->kernDev;
-}
-
-//==========================================================================
-
-int switchdev(int dev)
-{
-    bootInfo->kernDev = dev;
-    return dev;
-}
-
-//==========================================================================
-
-const char * usrDevices()
-{
-    if (gBootFileType == kNetworkDeviceType)
-	return "";
-    return "/private/Drivers/i386";
-}
-
-//==========================================================================
-
 const char * systemConfigDir()
 {
     if (gBootFileType == kNetworkDeviceType)
@@ -686,16 +678,35 @@
 #define RP ')'
 int gBIOSDev;
 
+/*!
+    This is like boot2's gBootVolume except it is for the internal use of
+    libsaio to track which volume an unqualified path should be relative to.
+    This replaces bootInfo->kernDev as the carrier of this information.
+ */
+static BVRef gRootVolume;
+
+void setRootVolume(BVRef volume)
+{
+    gRootVolume = volume;
+    // Veto non-native FS.  Basically that means don't allow the root volume to
+    // be set to a volume we can't read files from.
+    if(gRootVolume != NULL && ((gRootVolume->flags & kBVFlagNativeBoot) == 0))
+        gRootVolume = NULL;
+}
+
+/*!
+    Extracts the volume selector from the pathname, returns the selected
+    BVRef, and sets *outPath to the remainder of the path.
+    If the path did not include a volume selector then the current volume
+    is used.  When called with a volume selector the current volume
+    is changed to the selected volume unless the volume selector is
+    that of a ramdisk.
+ */
 BVRef getBootVolumeRef( const char * path, const char ** outPath )
 {
     const char * cp;
-    BVRef        bvr;
-    int          type = B_TYPE( bootInfo->kernDev );
-    int          unit = B_UNIT( bootInfo->kernDev );
-    int          part = B_PARTITION( bootInfo->kernDev );
+    BVRef bvr = gRootVolume;
     int          biosdev = gBIOSDev;
-    static BVRef lastBVR = 0;
-    static int   lastKernDev;
 
     // Search for left parenthesis in the path specification.
 
@@ -705,18 +716,19 @@
 
     if (*cp != LP)  // no left paren found
     {
+        // Path is using the implicit current device so if there is
+        // no current device, then we must fail.
         cp = path;
-        if ( lastBVR && lastKernDev == bootInfo->kernDev )
-        {
-            bvr = lastBVR;
-            goto quick_exit;
-        }
+        if ( gRootVolume == NULL )
+            return NULL;
     }
     else if ((cp - path) == 2)  // found "xx("
     {
         const struct devsw * dp;
         const char * xp = path;
         int          i;
+        int unit = -1;
+        int part = -1;
 
         cp++;
 
@@ -732,7 +744,6 @@
             error("Unknown device '%c%c'\n", xp[0], xp[1]);
             return NULL;
         }
-        type = dp - devsw;  // kerndev type
         
         // Extract the optional unit number from the specification.
         // hd(unit) or hd(unit, part).
@@ -744,17 +755,38 @@
             unit = i;
         }
 
+        // Unit is no longer optional and never really was.
+        // If the user failed to specify it then the unit number from the previous kernDev
+        // would have been used which makes little sense anyway.
+        // For example, if the user did fd()/foobar and the current root device was the
+        // second hard disk (i.e. unit 1) then fd() would select the second floppy drive!
+        if(unit == -1)
+            return NULL;
+
         // Extract the optional partition number from the specification.
 
         if (*cp == ',')
             part = atoi(++cp);
 
+        // If part is not specified part will be -1 whereas before it would have been
+        // whatever the last partition was which makes about zero sense if the device
+        // has been switched.
+
         // Skip past the right paren.
 
         for ( ; *cp && *cp != RP; cp++) /* LOOP */;
         if (*cp == RP) cp++;
         
         biosdev = dp->biosdev + unit;
+        bvr = newBootVolumeRef(biosdev, part);
+
+        if(bvr == NULL)
+            return NULL;
+
+        // Only record root volume if it is a real one, not a ramdisk.
+        // This means that rd(x) never becomes the "current" device.. which is good
+        if(biosdev < 0x100)
+            gRootVolume = bvr;
     }
     else
     {
@@ -762,23 +794,10 @@
 
         for ( cp++; *cp && *cp != RP; cp++) /* LOOP */;
         if (*cp == RP) cp++;
+        // If gRootVolume was NULL, then bvr will be NULL as well which
+        // should be caught by the caller.
     }
 
-    if ((bvr = newBootVolumeRef(biosdev, part)) == NULL)
-    {
-        // error("newBootVolumeRef() error\n");
-        return NULL;
-    }
-
-    // Record the most recent device parameters in the
-    // KernBootStruct.
-
-    bootInfo->kernDev = biosdev;
-
-    lastBVR = bvr;
-    lastKernDev = bootInfo->kernDev;
-
-quick_exit:
     // Returns the file path following the device spec.
     // e.g. 'hd(1,b)mach_kernel' is reduced to 'mach_kernel'.
 
@@ -789,6 +808,8 @@
 
 //==========================================================================
 
+// Function name is a misnomer as scanBootVolumes usually calls diskScanBootVolumes
+// which caches the information.  So it's only allocated on the first run.
 static BVRef newBootVolumeRef( int biosdev, int partno )
 {
     BVRef bvr, bvr1, bvrChain;
Index: i386/libsaio/nbp.c
===================================================================
--- i386/libsaio/nbp.c	(.../vendor/132)	(revision 146)
+++ i386/libsaio/nbp.c	(.../branches/public)	(revision 146)
@@ -24,6 +24,23 @@
 
 #include "libsaio.h"
 
+/*  This NBP code is pretty useless because it just blindly calls INT 2B.
+    Presumably INT 2B was implemented by some first-stage bootloader that
+    is long gone.
+
+    One good reason to disable this is that nbpScanBootVolumes always
+    succeeds.  The scanBootVolumes function thus never fails because
+    it always falls back to NBP.  This is a problem because there is
+    other code in the booter (for example, in open) which needs to
+    fail instead of attempting to use this NBP which will often
+    hang the machine.
+ */
+#ifndef NBP_SUPPORT
+#define NBP_SUPPORT 0
+#endif
+
+#if NBP_SUPPORT
+
 /*
  * Convert zero-based linear address to far pointer.
  */
@@ -116,3 +133,13 @@
     }
     return gNetBVR;
 }
+#else
+BVRef nbpScanBootVolumes( int biosdev, int * countPtr )
+{
+    return NULL;
+}
+UInt32 nbpUnloadBaseCode()
+{
+    return 0;
+}
+#endif
Index: i386/libsaio/load.c
===================================================================
--- i386/libsaio/load.c	(.../vendor/132)	(revision 146)
+++ i386/libsaio/load.c	(.../branches/public)	(revision 146)
@@ -211,7 +211,11 @@
   i386ThreadState = (i386_thread_state_t *)
     (cmdBase + sizeof(struct thread_command) + 8);
   
+#if defined(__DARWIN_UNIX03) && __DARWIN_UNIX03
+  *entry = i386ThreadState->__eip;
+#else
   *entry = i386ThreadState->eip;
+#endif
   
   return 0;
 }
Index: i386/libsaio/hfs.c
===================================================================
--- i386/libsaio/hfs.c	(.../vendor/132)	(revision 146)
+++ i386/libsaio/hfs.c	(.../branches/public)	(revision 146)
@@ -120,6 +120,13 @@
     // Don't bother with location
 }
 
+void HFSFree(CICell ih)
+{
+    if(gCurrentIH == ih)
+        gCurrentIH = 0;
+    free(ih);
+}
+
 long HFSInitPartition(CICell ih)
 {
     long extentSize, extentFile, nodeSize;
@@ -595,6 +602,7 @@
         strncpy(gTempStr,
                 (const char *)&((HFSCatalogKey *)testKey)->nodeName[1],
                  ((HFSCatalogKey *)testKey)->nodeName[0]);
+        gTempStr[((HFSCatalogKey *)testKey)->nodeName[0]] = '\0';
     }
     *name = gTempStr;
 
Index: i386/libsaio/hfs.h
===================================================================
--- i386/libsaio/hfs.h	(.../vendor/132)	(revision 146)
+++ i386/libsaio/hfs.h	(.../branches/public)	(revision 146)
@@ -29,3 +29,4 @@
 extern void HFSGetDescription(CICell ih, char *str, long strMaxLen);
 extern long HFSGetFileBlock(CICell ih, char *str, unsigned long long *firstBlock);
 extern long HFSGetUUID(CICell ih, char *uuidStr);
+extern void HFSFree(CICell ih);
Index: i386/libsaio/hfs_compare.c
===================================================================
--- i386/libsaio/hfs_compare.c	(.../vendor/132)	(revision 146)
+++ i386/libsaio/hfs_compare.c	(.../branches/public)	(revision 146)
@@ -41,6 +41,13 @@
     int i, j;
 
     for (i=0; i<count; i++, bp++) {
+        // If this happens (it shouldn't) please fix size and/or double check that count really is
+        // the number of elements in the array.
+        // This was a very hard bug to find, so please leave this code here.
+        if(out + size <= op + bp->count)
+        {
+            stop("HFS+ Unicode tables are malformed\n");
+        }
         data = bp->data;
         for (j=0; j<bp->count; j++) {
             *op++ = data;
Index: i386/libsaio/disk.c
===================================================================
--- i386/libsaio/disk.c	(.../vendor/132)	(revision 146)
+++ i386/libsaio/disk.c	(.../branches/public)	(revision 146)
@@ -44,7 +44,15 @@
  * All rights reserved.
  */
 
+/*  Copyright 2007 VMware Inc.
+    "Preboot" ramdisk support added by David Elliott
+    GPT support added by David Elliott.  Based on IOGUIDPartitionScheme.cpp.
+ */
+
+// Allow UFS_SUPPORT to be overridden with preprocessor option.
+#ifndef UFS_SUPPORT
 #define UFS_SUPPORT 1
+#endif
 
 #include "bootstruct.h"
 #include "libsaio.h"
@@ -58,7 +66,14 @@
 
 #include <limits.h>
 #include <IOKit/storage/IOApplePartitionScheme.h>
+#include <IOKit/storage/IOGUIDPartitionScheme.h>
+typedef struct gpt_hdr gpt_hdr;
+typedef struct gpt_ent gpt_ent;
 
+// For EFI_GUID
+#include <pexpert/i386/efi.h>
+#include "efi_tables.h"
+
 #define BPS              512     /* sector size of the device */
 #define CD_BPS           2048    /* CD-ROM block size */
 #define N_CACHE_SECS     (BIOS_LEN / BPS)  /* Must be a multiple of 4 for CD-ROMs */
@@ -67,6 +82,16 @@
 #define kAPMCDSector     8       /* Translated sector of Apple partition map on a CD */
 
 /*
+ * IORound and IOTrunc convenience functions, in the spirit
+ * of vm's round_page() and trunc_page().
+ */
+#define IORound(value,multiple) \
+        ((((value) + (multiple) - 1) / (multiple)) * (multiple))
+
+#define IOTrunc(value,multiple) \
+        (((value) / (multiple)) * (multiple));
+
+/*
  * trackbuf points to the start of the track cache. Biosread()
  * will store the sectors read from disk to this memory area.
  *
@@ -89,6 +114,13 @@
 static struct DiskBVMap * gDiskBVMap  = NULL;
 static struct disk_blk0 * gBootSector = NULL;
 
+// Function pointers to be filled in if ramdisks are available:
+int (*p_ramdiskReadBytes)( int biosdev, unsigned int blkno,
+                      unsigned int byteoff,
+                      unsigned int byteCount, void * buffer ) = NULL;
+int (*p_get_ramdisk_info)(int biosdev, struct driveInfo *dip) = NULL;
+
+
 extern void spinActivityIndicator();
 
 static void getVolumeDescription(BVRef bvr, char * str, long strMaxLen);
@@ -100,6 +132,24 @@
     static struct driveInfo cached_di;
     int cc;
     
+    // Real BIOS devices are 8-bit, so anything above that is for internal use.
+    // Don't cache ramdisk drive info since it doesn't require several BIOS
+    // calls and is thus not worth it.
+    if(biosdev >= 0x100)
+    {
+        if(p_get_ramdisk_info != NULL)
+            cc = (*p_get_ramdisk_info)(biosdev, dip);
+        else
+            cc = -1;
+        if(cc < 0)
+        {
+            dip->valid = 0;
+            return -1;
+        }
+        else
+            return 0;
+    }
+
     if ( !cached_di.valid || biosdev != cached_di.biosdev )
     {
 	cc = get_drive_info(biosdev, &cached_di);
@@ -290,6 +340,9 @@
                       unsigned int byteoff,
                       unsigned int byteCount, void * buffer )
 {
+    // ramdisks require completely different code for reading.
+    if(p_ramdiskReadBytes != NULL && biosdev >= 0x100)
+        return (*p_ramdiskReadBytes)(biosdev, blkno, byteoff, byteCount, buffer);
 
     char * cbuf = (char *) buffer;
     int    error;
@@ -436,6 +489,7 @@
                             FSGetFileBlock getBlockFunc,
                             FSGetUUID getUUIDFunc,
                             BVGetDescription getDescriptionFunc,
+                            BVFree bvFreeFunc,
                             int probe, int type )
 {
     BVRef bvr = (BVRef) malloc( sizeof(*bvr) );
@@ -455,6 +509,7 @@
         bvr->description    = getDescriptionFunc ?
             getDescriptionFunc : getVolumeDescription;
 	bvr->type           = type;
+        bvr->bv_free        = bvFreeFunc;
 
         if ( part->bootid & FDISK_ACTIVE )
             bvr->flags |= kBVFlagPrimary;
@@ -472,7 +527,7 @@
                 DEBUG_DISK(("%s: failed probe on dev %x part %d\n",
                             __FUNCTION__, biosdev, partno));
 
-                free(bvr);
+                (*bvr->bv_free)(bvr);
                 bvr = NULL;
             }
         }
@@ -482,7 +537,7 @@
         }
         else
         {
-            free(bvr);
+            (*bvr->bv_free)(bvr);
             bvr = NULL;
         }
     }
@@ -499,6 +554,7 @@
                    FSGetFileBlock getBlockFunc,
                    FSGetUUID getUUIDFunc,
                    BVGetDescription getDescriptionFunc,
+                   BVFree bvFreeFunc,
                    int probe, int type )
 {
     BVRef bvr = (BVRef) malloc( sizeof(*bvr) );
@@ -517,6 +573,7 @@
         bvr->description    = getDescriptionFunc ?
             getDescriptionFunc : getVolumeDescription;
 	bvr->type           = type;
+        bvr->bv_free        = bvFreeFunc;
         strlcpy(bvr->name, part->dpme_name, DPISTRLEN);
         strlcpy(bvr->type_name, part->dpme_type, DPISTRLEN);
 
@@ -538,7 +595,7 @@
                 DEBUG_DISK(("%s: failed probe on dev %x part %d\n",
                             __FUNCTION__, biosdev, partno));
 
-                free(bvr);
+                (*bvr->bv_free)(bvr);
                 bvr = NULL;
             }
         }
@@ -550,7 +607,7 @@
         */
         else
         {
-            free(bvr);
+            (*bvr->bv_free)(bvr);
             bvr = NULL;
         }
     }
@@ -559,6 +616,77 @@
 
 //==========================================================================
 
+BVRef newGPTBVRef( int biosdev, int partno, unsigned int blkoff,
+                   const gpt_ent * part,
+                   FSInit initFunc, FSLoadFile loadFunc,
+                   FSReadFile readFunc,
+                   FSGetDirEntry getdirFunc,
+                   FSGetFileBlock getBlockFunc,
+                   FSGetUUID getUUIDFunc,
+                   BVGetDescription getDescriptionFunc,
+                   BVFree bvFreeFunc,
+                   int probe, int type )
+{
+    BVRef bvr = (BVRef) malloc( sizeof(*bvr) );
+    if ( bvr )
+    {
+        bzero(bvr, sizeof(*bvr));
+
+        bvr->biosdev        = biosdev;
+        bvr->part_no        = partno;
+        bvr->part_boff      = blkoff;
+        bvr->fs_loadfile    = loadFunc;
+        bvr->fs_readfile    = readFunc;
+        bvr->fs_getdirentry = getdirFunc;
+        bvr->fs_getfileblock= getBlockFunc;
+        bvr->fs_getuuid     = getUUIDFunc;
+        bvr->description    = getDescriptionFunc ?
+            getDescriptionFunc : getVolumeDescription;
+	bvr->type           = type;
+        bvr->bv_free        = bvFreeFunc;
+        // FIXME: UCS-2 -> UTF-8 the name
+        strlcpy(bvr->name, "----", DPISTRLEN);
+        strlcpy(bvr->type_name, "GPT HFS+", DPISTRLEN);
+
+        /*
+        if ( part->bootid & FDISK_ACTIVE )
+            bvr->flags |= kBVFlagPrimary;
+        */
+
+        // Probe the filesystem.
+
+        if ( initFunc )
+        {
+            bvr->flags |= kBVFlagNativeBoot;
+
+            if ( probe && initFunc( bvr ) != 0 )
+            {
+                // filesystem probe failed.
+
+                DEBUG_DISK(("%s: failed probe on dev %x part %d\n",
+                            __FUNCTION__, biosdev, partno));
+
+                (*bvr->bv_free)(bvr);
+                bvr = NULL;
+            }
+        }
+        /*
+        else if ( readBootSector( biosdev, blkoff, (void *)0x7e00 ) == 0 )
+        {
+            bvr->flags |= kBVFlagForeignBoot;
+        }
+        */
+        else
+        {
+            (*bvr->bv_free)(bvr);
+            bvr = NULL;
+        }
+    }
+    return bvr;
+}
+
+//==========================================================================
+
 /* A note on partition numbers:
  * IOKit makes the primary partitions numbers 1-4, and then
  * extended partitions are numbered consecutively 5 and up.
@@ -625,6 +753,7 @@
                                       UFSGetFileBlock,
                                       UFSGetUUID,
                                       UFSGetDescription,
+                                      UFSFree,
                                       0,
 				      kBIOSDevTypeHardDrive);
                         break;
@@ -642,6 +771,7 @@
                                       HFSGetFileBlock,
                                       HFSGetUUID,
                                       HFSGetDescription,
+                                      HFSFree,
                                       0,
 				      kBIOSDevTypeHardDrive);
                         break;
@@ -659,6 +789,7 @@
                                       UFSGetFileBlock,
                                       UFSGetUUID,
                                       UFSGetDescription,
+                                      UFSFree,
                                       0,
 				      kBIOSDevTypeHardDrive);
                         break;
@@ -671,6 +802,7 @@
                                       part,
                                       0, 0, 0, 0, 0, 0,
                                       NTFSGetDescription,
+                                      (BVFree)free,
                                       0,
 				      kBIOSDevTypeHardDrive);
                         break;
@@ -680,7 +812,9 @@
                                       biosdev, partno,
                                       part->relsect,
                                       part,
-                                      0, 0, 0, 0, 0, 0, 0, 0,
+                                      0, 0, 0, 0, 0, 0, 0,
+                                      (BVFree)free,
+                                      0,
 				      kBIOSDevTypeHardDrive);
                         break;
                 }
@@ -737,6 +871,17 @@
 	map->bvrcnt++;
     }
 #endif
+    // Actually this should always be true given the above code
+    if(map == gDiskBVMap)
+    {
+        // Don't leave a null map in the chain
+        if(map->bvrcnt == 0 && map->bvr == NULL)
+        {
+            gDiskBVMap = map->next;
+            free(map);
+            map = NULL;
+        }
+    }
 
     if (countPtr) *countPtr = map ? map->bvrcnt : 0;
 
@@ -817,6 +962,7 @@
                                       HFSGetFileBlock,
                                       HFSGetUUID,
                                       HFSGetDescription,
+                                      HFSFree,
                                       0,
                                       kBIOSDevTypeHardDrive);
                     bvr->next = map->bvr;
@@ -836,6 +982,228 @@
 
 //==========================================================================
 
+// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+
+static bool isPartitionUsed(gpt_ent * partition)
+{
+    //
+    // Ask whether the given partition is used.
+    //
+
+    return efi_guid_is_null((EFI_GUID const*)partition->ent_type) ? false : true;
+}
+
+// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+
+// HFS+ GUID in LE form
+EFI_GUID const GPT_HFS_GUID = { 0x48465300, 0x0000, 0x11AA, { 0xAA, 0x11, 0x00, 0x30, 0x65, 0x43, 0xEC, 0xAC } };
+
+static BVRef diskScanGPTBootVolumes( int biosdev, int * countPtr )
+{
+    struct DiskBVMap *        map = NULL;
+    void *buffer = malloc(BPS);
+    int error;
+    if ( error = readBytes( biosdev, /*secno*/0, 0, BPS, buffer ) != 0) {
+        verbose("Failed to read boot sector from BIOS device %02xh. Error=%d\n", biosdev, error);
+        goto scanErr;
+    }
+    struct REAL_disk_blk0 *fdiskMap = buffer;
+    if ( OSSwapLittleToHostInt16(fdiskMap->signature) != DISK_SIGNATURE )
+    {
+        verbose("Failed to find boot signature on BIOS device %02xh\n", biosdev);
+        goto scanErr;
+    }
+
+    int fdiskID = 0;
+    unsigned index;
+    for ( index = 0; index < FDISK_NPART; index++ )
+    {
+        if ( fdiskMap->parts[index].systid )
+        {
+            if ( fdiskMap->parts[index].systid == 0xEE )
+            {
+                // Fail if two 0xEE partitions are present which
+                // means the FDISK code will wind up parsing it.
+                if ( fdiskID )  goto scanErr;
+
+                fdiskID = index + 1;
+            }
+        }
+    }
+
+    if ( fdiskID == 0 )  goto scanErr;
+    verbose("Attempting to read GPT\n");
+
+    if(readBytes(biosdev, 1, 0, BPS, buffer) != 0)
+        goto scanErr;
+    
+    gpt_hdr *headerMap = buffer;
+
+    // Determine whether the partition header signature is present.
+
+    if ( memcmp(headerMap->hdr_sig, GPT_HDR_SIG, strlen(GPT_HDR_SIG)) )
+    {
+        goto scanErr;
+    }
+
+    // Determine whether the partition header size is valid.
+
+    UInt32 headerCheck = OSSwapLittleToHostInt32(headerMap->hdr_crc_self);
+    UInt32 headerSize  = OSSwapLittleToHostInt32(headerMap->hdr_size);
+
+    if ( headerSize < offsetof(gpt_hdr, padding) )
+    {
+        goto scanErr;
+    }
+
+    if ( headerSize > BPS )
+    {
+        goto scanErr;
+    }
+
+    // Determine whether the partition header checksum is valid.
+
+    headerMap->hdr_crc_self = 0;
+
+    if ( crc32(0, headerMap, headerSize) != headerCheck )
+    {
+        goto scanErr;
+    }
+
+    // Determine whether the partition entry size is valid.
+
+    UInt64                     gptBlock       = 0;
+    UInt32                     gptCheck       = 0;
+    UInt32                     gptCount       = 0;
+    UInt32                     gptID          = 0;
+    gpt_ent *                  gptMap         = 0;
+    UInt32                     gptSize        = 0;
+
+    gptBlock = OSSwapLittleToHostInt64(headerMap->hdr_lba_table);
+    gptCheck = OSSwapLittleToHostInt32(headerMap->hdr_crc_table);
+    gptCount = OSSwapLittleToHostInt32(headerMap->hdr_entries);
+    gptSize  = OSSwapLittleToHostInt32(headerMap->hdr_entsz);
+
+    if ( gptSize < sizeof(gpt_ent) )
+    {
+        goto scanErr;
+    }
+
+    // Allocate a buffer large enough to hold one map, rounded to a media block.
+    free(buffer);
+    buffer = NULL;
+
+    UInt32 bufferSize = IORound(gptCount * gptSize, BPS);
+    if(bufferSize == 0)
+        goto scanErr;
+    buffer = malloc(bufferSize);
+
+    if(readBytes(biosdev, gptBlock, 0, bufferSize, buffer) != 0)
+        goto scanErr;
+
+    verbose("Read GPT\n");
+
+    // Allocate a new map for this BIOS device and insert it into the chain
+    map = malloc(sizeof(*map));
+    map->biosdev = biosdev;
+    map->bvr = NULL;
+    map->bvrcnt = 0;
+    map->next = gDiskBVMap;
+    gDiskBVMap = map;
+
+    for(gptID = 1; gptID <= gptCount; ++gptID)
+    {
+        // size on disk can be larger than sizeof(gpt_ent)
+        gptMap = (gpt_ent *) ( buffer + ( (gptID - 1) * gptSize)  );
+
+        // NOTE: EFI_GUID's are in LE and we know we're on an x86.
+        // The IOGUIDPartitionScheme.cpp code uses byte-based UUIDs, we don't.
+
+        if(isPartitionUsed(gptMap))
+        {
+            char stringuuid[100];
+            efi_guid_unparse_upper((EFI_GUID*)gptMap->ent_type, stringuuid);
+            verbose("Reading GPT partition %d, type %s\n", gptID, stringuuid);
+            if(efi_guid_compare(&GPT_HFS_GUID, (EFI_GUID const*)gptMap->ent_type) == 0)
+            {
+                BVRef bvr = newGPTBVRef(biosdev,
+                                      gptID,
+                                      gptMap->ent_lba_start,
+                                      gptMap,
+                                      HFSInitPartition,
+                                      HFSLoadFile,
+                                      HFSReadFile,
+                                      HFSGetDirEntry,
+                                      HFSGetFileBlock,
+                                      HFSGetUUID,
+                                      HFSGetDescription,
+                                      HFSFree,
+                                      0,
+                                      kBIOSDevTypeHardDrive);
+                bvr->next = map->bvr;
+                map->bvr = bvr;
+                ++map->bvrcnt;
+            }
+            
+        }
+    }
+
+scanErr:
+    free(buffer);
+
+    if(map)
+    {
+        if(countPtr) *countPtr = map->bvrcnt;
+        return map->bvr;
+    }
+    else
+    {
+        if(countPtr) *countPtr = 0;
+        return NULL;
+    }
+}
+
+//==========================================================================
+struct DiskBVMap* diskResetBootVolumes(int biosdev)
+{
+    struct DiskBVMap *        map;
+    struct DiskBVMap *prevMap = NULL;
+    for ( map = gDiskBVMap; map; prevMap = map, map = map->next ) {
+        if ( biosdev == map->biosdev ) {
+            break;
+        }
+    }
+    if(map != NULL)
+    {
+        verbose("Resetting BIOS device %xh\n", biosdev);
+        // Reset the biosbuf cache
+        cache_valid = FALSE;
+        if(map == gDiskBVMap)
+            gDiskBVMap = map->next;
+        else if(prevMap != NULL)
+            prevMap->next = map->next;
+        else
+            stop("");
+    }
+    // Return the old map, either to be freed, or reinserted later
+    return map;
+}
+
+// Frees a DiskBVMap and all of its BootVolume's
+void diskFreeMap(struct DiskBVMap *map)
+{
+    if(map != NULL)
+    {
+        while(map->bvr != NULL)
+        {
+            BVRef bvr = map->bvr;
+            map->bvr = bvr->next;
+            (*bvr->bv_free)(bvr);
+        }
+        free(map);
+    }
+}
+
 BVRef diskScanBootVolumes( int biosdev, int * countPtr )
 {
     struct DiskBVMap *        map;
@@ -852,8 +1220,11 @@
     }
 
     if (map == NULL) {
-        bvr = diskScanFDiskBootVolumes(biosdev, &count);
+        bvr = diskScanGPTBootVolumes(biosdev, &count);
         if (bvr == NULL) {
+            bvr = diskScanFDiskBootVolumes(biosdev, &count);
+        }
+        if (bvr == NULL) {
             bvr = diskScanAPMBootVolumes(biosdev, &count);
         }
     } else {
Index: i386/libsaio/Makefile
===================================================================
--- i386/libsaio/Makefile	(.../vendor/132)	(revision 146)
+++ i386/libsaio/Makefile	(.../branches/public)	(revision 146)
@@ -11,7 +11,7 @@
 CFLAGS	= $(RC_CFLAGS) $(OPTIM) $(MORECPP) -arch i386 -g -Wmost \
     -D__ARCHITECTURE__=\"i386\" -DSAIO_INTERNAL_USER \
     -DRCZ_COMPRESSED_FILE_SUPPORT \
-    -fno-builtin -static -fomit-frame-pointer \
+    -fno-builtin -static $(OMIT_FRAME_POINTER_CFLAG) \
     -mpreferred-stack-boundary=2 -fno-align-functions \
     -mno-sse2 -mfpmath=387
 DEFINES=
@@ -34,7 +34,8 @@
 	stringTable.o load.o memory.o misc.o \
 	ufs.o ufs_byteorder.o \
 	vbe.o nbp.o hfs.o hfs_compare.o \
-	xml.o ntfs.o msdos.o md5c.o device_tree.o
+	xml.o ntfs.o msdos.o md5c.o device_tree.o \
+	fake_efi.o
 
 
 SAIO_EXTERN_OBJS = console.o
Index: i386/libsaio/ufs.c
===================================================================
--- i386/libsaio/ufs.c	(.../vendor/132)	(revision 146)
+++ i386/libsaio/ufs.c	(.../branches/public)	(revision 146)
@@ -100,6 +100,13 @@
 
 // Public functions
 
+void UFSFree(CICell ih)
+{
+    if(gCurrentIH == ih)
+        gCurrentIH = 0;
+    free(ih);
+}
+
 long UFSInitPartition( CICell ih )
 {
 #if !BOOT1
Index: i386/libsaio/SMBIOS.h
===================================================================
--- i386/libsaio/SMBIOS.h	(.../vendor/132)	(revision 0)
+++ i386/libsaio/SMBIOS.h	(.../branches/public)	(revision 146)
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 1998-2006 Apple Computer, Inc. All rights reserved.
+ *
+ * @APPLE_LICENSE_HEADER_START@
+ * 
+ * The contents of this file constitute Original Code as defined in and
+ * are subject to the Apple Public Source License Version 1.1 (the
+ * "License").  You may not use this file except in compliance with the
+ * License.  Please obtain a copy of the License at
+ * http://www.apple.com/publicsource and read it before using this file.
+ * 
+ * This Original Code and all software distributed under the License are
+ * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
+ * License for the specific language governing rights and limitations
+ * under the License.
+ * 
+ * @APPLE_LICENSE_HEADER_END@
+ */
+
+/* This file is a stripped-down version of the one found in the AppleSMBIOS project.
+ * Changes:
+ * - Don't use pragma pack but instead use GCC's packed attribute
+ * - Remove everything except the entry point structure.  We don't need anything else.
+ */
+
+#ifndef _LIBSAIO_SMBIOS_H
+#define _LIBSAIO_SMBIOS_H
+
+/*
+ * Based on System Management BIOS Reference Specification v2.5
+ */
+
+typedef UInt8  SMBString;
+typedef UInt8  SMBByte;
+typedef UInt16 SMBWord;
+typedef UInt32 SMBDWord;
+typedef UInt64 SMBQWord;
+
+struct DMIEntryPoint {
+    SMBByte    anchor[5];
+    SMBByte    checksum;
+    SMBWord    tableLength;
+    SMBDWord   tableAddress;
+    SMBWord    structureCount;
+    SMBByte    bcdRevision;
+} __attribute__((packed));
+
+struct SMBEntryPoint {
+    SMBByte    anchor[4];
+    SMBByte    checksum;
+    SMBByte    entryPointLength;
+    SMBByte    majorVersion;
+    SMBByte    minorVersion;
+    SMBWord    maxStructureSize;
+    SMBByte    entryPointRevision;
+    SMBByte    formattedArea[5];
+    struct DMIEntryPoint dmi;
+} __attribute__((packed));
+
+#endif /* !_LIBSAIO_SMBIOS_H */
Index: i386/libsaio/ufs.h
===================================================================
--- i386/libsaio/ufs.h	(.../vendor/132)	(revision 146)
+++ i386/libsaio/ufs.h	(.../branches/public)	(revision 146)
@@ -29,4 +29,5 @@
 extern void UFSGetDescription(CICell ih, char *str, long strMaxLen);
 extern long UFSGetFileBlock(CICell ih, char *str, unsigned long long *firstBlock);
 extern long UFSGetUUID(CICell ih, char *uuidStr);
+extern void UFSFree(CICell ih);
 
Index: i386/libsaio/cache.c
===================================================================
--- i386/libsaio/cache.c	(.../vendor/132)	(revision 146)
+++ i386/libsaio/cache.c	(.../branches/public)	(revision 146)
@@ -61,6 +61,11 @@
 unsigned long     gCacheEvicts;
 #endif
 
+void CacheReset()
+{
+    gCacheIH = NULL;
+}
+
 void CacheInit( CICell ih, long blockSize )
 {
 #ifdef __i386__
Index: i386/libsaio/bios.s
===================================================================
--- i386/libsaio/bios.s	(.../vendor/132)	(revision 146)
+++ i386/libsaio/bios.s	(.../branches/public)	(revision 146)
@@ -28,6 +28,12 @@
  * Harness for calling real-mode BIOS functions.
  */
 
+/*  Copyright 2007 David Elliott
+    2007-12-30 dfe
+    - Enhanced code to use specified DS register when doing BIOS interrupt
+    - Fixed movl %ax,new_es bug which assembler was interpreting as
+      movl %eax,new_es which was overwriting the next word.
+ */
 #include <architecture/i386/asm_help.h>
 #include "memory.h"
 
@@ -48,14 +54,48 @@
 #define O_FLG   38
 
 .data
-    .lcomm save_eax,  4,2
-    .lcomm save_edx,  4,2
-    .lcomm save_es,   2,1
-    .lcomm save_flag, 2,1
-    .lcomm new_eax,   4,2
-    .lcomm new_edx,   4,2
-    .lcomm new_es,    2,1
+/*  Saved registers:
+    These used to be (and in theory ought to be) located in __DATA,__bss.
+    The problem is that the larger the binary grows, more of the BSS gets
+    pushed into the next real-mode segment.  Doing it this way we waste 24
+    bytes in the binary that our loader (e.g. boot1) must now load.  But the
+    advantage is that we relocate this data to ensure it stays in the first
+    real-mode segment.  Therefore, depending on link order, quite a lot of
+    new data, and possibly a lot of new executable code can be added to the
+    binary since with this change the BSS and most of the DATA is now only
+    accessed from protected mode where real-mode segment limits don't apply.
 
+    With this change, plus the earlier change to respect DS (e.g. use huge
+    pointers), the binary can grow much larger, currently up to exactly 63.5k
+    which is the maximum that the first-stage bootsectors can handle.  To get
+    more than that more changes are needed.  In that case we would have to
+    play with Mach-O segments to ensure real-mode code and data got stuffed
+    well within the first 63.5k.  Furthermore, we'd have to adjust the boot
+    sectors to allow them to span segments.
+
+    Since this change alone only gains us about 4k more than where we're at
+    now (which is not anything to scoff at) it won't be very long before we
+    need to start using Mach-O segments to force the linker to locate certain
+    bits of code and data within the first 63.5k and modify the loaders to
+    be able to load more than 63.5k.
+ */
+    .align 2
+save_eax:   .space 4
+    .align 2
+save_edx:   .space 4
+    .align 1
+save_es:    .space 2
+    .align 1
+save_flag:  .space 2
+    .align 2
+new_eax:    .space 4
+    .align 2
+new_edx:    .space 4
+    .align 1
+new_es:     .space 2
+    .align 1
+new_ds:     .space 2
+
 .text
 
 /*============================================================================
@@ -81,7 +121,9 @@
     movl    O_EDX(%edx), %eax
     movl    %eax, new_edx
     movw    O_ES(%edx),  %ax
-    movl    %ax, new_es
+    movw    %ax, new_es
+    movw    O_DS(%edx),  %ax
+    movw    %ax, new_ds
 
     call    __prot_to_real
 
@@ -95,8 +137,16 @@
     addr32
     mov     OFFSET16(new_es), %es
 
+    push    %ds     // Save DS
+    // Replace DS. WARNING: Don't access data until it's restored!
+    addr32
+    data32
+    mov     OFFSET16(new_ds), %ds
+
 do_int:
     int     $0x00
+    pop     %ds     // Restore DS before we do anything else
+
     pushf
     data32
     addr32
Index: i386/libsaio/biosfn.c
===================================================================
--- i386/libsaio/biosfn.c	(.../vendor/132)	(revision 146)
+++ i386/libsaio/biosfn.c	(.../branches/public)	(revision 146)
@@ -26,6 +26,19 @@
  * All rights reserved.
  */
 
+/*  Copyright 2007 David Elliott
+    2007-12-30 dfe
+    - Enhanced code to normalize segment/offset to huge pointers so that any
+      linear address within the first MB of memory can be passed to BIOS
+      functions.  This allows some of the __DATA sections to span into the
+      next segment and also allows stack variables to be used whereas the
+      old code could only operate on static data in the first 64k.
+      NOTE: Requires bios.s change to respect DS.
+ */
+/*  Copyright 2007 VMware Inc.
+    2007-12-29 dfe
+    - Added ebiosEjectMedia
+ */
 #include "bootstruct.h"
 #include "libsaio.h"
 
@@ -35,6 +48,13 @@
 
 int bgetc(void)
 {
+    /*  Poll for the next character.  Most real BIOS do not need this as the
+        INT 16h,AH=0h function will block until one is received.
+        Unfortunately, Apple's EFI CSM will never wake up.  This idea is lifted
+        from the grub-a20.patch to GRUB's stage2/asm.S file.
+     */
+    while(!readKeyboardStatus())
+        ;
     bb.intno = 0x16;
     bb.eax.r.h = 0x00;
     bios(&bb);
@@ -115,8 +135,8 @@
         bb.eax.rx = 0xe820;
         bb.ecx.rx = kDescriptorSizeMin;
         bb.edx.rx = kMemoryMapSignature;
-        bb.edi.rr = OFFSET(  (unsigned long) range );
-        bb.es     = SEGMENT( (unsigned long) range );
+        bb.edi.rr = NORMALIZED_OFFSET(  (unsigned long) range );
+        bb.es     = NORMALIZED_SEGMENT( (unsigned long) range );
         bios(&bb);
 
         // Check for errors.
@@ -289,8 +309,8 @@
         bb.intno   = 0x13;
         bb.eax.r.h = 0x42;
         bb.edx.r.l = dev;
-        bb.esi.rr  = OFFSET((unsigned)&addrpacket);
-        bb.ds      = SEGMENT((unsigned)&addrpacket);
+        bb.esi.rr  = NORMALIZED_OFFSET((unsigned)&addrpacket);
+        bb.ds      = NORMALIZED_SEGMENT((unsigned)&addrpacket);
         addrpacket.reserved = addrpacket.reserved2 = 0;
         addrpacket.numblocks     = count;
         addrpacket.bufferOffset  = OFFSET(ptov(BIOS_ADDR));
@@ -326,8 +346,8 @@
         bb.eax.r.l = 0; /* Don't verify */
         bb.eax.r.h = 0x43;
         bb.edx.r.l = dev;
-        bb.esi.rr  = OFFSET((unsigned)&addrpacket);
-        bb.ds      = SEGMENT((unsigned)&addrpacket);
+        bb.esi.rr  = NORMALIZED_OFFSET((unsigned)&addrpacket);
+        bb.ds      = NORMALIZED_SEGMENT((unsigned)&addrpacket);
         addrpacket.reserved = addrpacket.reserved2 = 0;
         addrpacket.numblocks     = count;
         addrpacket.bufferOffset  = OFFSET(ptov(BIOS_ADDR));
@@ -392,8 +412,8 @@
     bb.eax.r.h = 0x4b;
     bb.eax.r.l = 0x01;     // subfunc: get info
     bb.edx.r.l = drive;
-    bb.esi.rr = OFFSET((unsigned)&pkt);
-    bb.ds     = SEGMENT((unsigned)&pkt);
+    bb.esi.rr = NORMALIZED_OFFSET((unsigned)&pkt);
+    bb.ds     = NORMALIZED_SEGMENT((unsigned)&pkt);
 
     bios(&bb);
 #if DEBUG
@@ -510,8 +530,8 @@
         bb.intno = 0x13;
         bb.eax.r.h = 0x48;
         bb.edx.r.l = drive;
-        bb.esi.rr = OFFSET((unsigned)&params);
-        bb.ds     = SEGMENT((unsigned)&params);
+        bb.esi.rr = NORMALIZED_OFFSET((unsigned)&params);
+        bb.ds     = NORMALIZED_SEGMENT((unsigned)&params);
         bios(&bb);
         if(bb.flags.cf != 0 /* || params.phys_sectors < 2097152 */) {
             dp->uses_ebios = 0;
@@ -576,6 +596,16 @@
     return ret;
 }
 
+int ebiosEjectMedia(int biosdev)
+{
+    bb.intno = 0x13;
+    bb.eax.r.h = 0x46;
+    bb.eax.r.l = 0;
+    bb.edx.rx = biosdev;
+    bios(&bb);
+    return bb.eax.r.h;
+}
+
 void setCursorPosition(int x, int y, int page)
 {
     bb.intno = 0x10;
@@ -639,8 +669,8 @@
     bb.intno   = 0x13;
     bb.eax.r.h = 0x4b;
     bb.eax.r.l = 0;     // subfunc: terminate emulation    
-    bb.esi.rr  = OFFSET((unsigned)&cd_spec);
-    bb.ds      = SEGMENT((unsigned)&cd_spec);
+    bb.esi.rr  = NORMALIZED_OFFSET((unsigned)&cd_spec);
+    bb.ds      = NORMALIZED_SEGMENT((unsigned)&cd_spec);
     bios(&bb);
     return bb.eax.r.h;
 }
Index: i386/libsaio/saio_types.h
===================================================================
--- i386/libsaio/saio_types.h	(.../vendor/132)	(revision 146)
+++ i386/libsaio/saio_types.h	(.../branches/public)	(revision 146)
@@ -128,6 +128,8 @@
                               FinderInfo * finderInfo, long * infoValid);
 typedef long (* FSGetUUID)(CICell ih, char *uuidStr);
 typedef void (*BVGetDescription)(CICell ih, char * str, long strMaxLen);
+// Can be just pointed to free or a special free function
+typedef void (*BVFree)(CICell ih);
 
 struct iob {
     unsigned int   i_flgs;          /* see F_* below */
@@ -171,6 +173,7 @@
     unsigned int     bps;             /* bytes per sector for this device */
     char             name[BVSTRLEN];  /* (name of partition) */
     char             type_name[BVSTRLEN]; /* (type of partition, eg. Apple_HFS) */
+    BVFree           bv_free;         /* BVFree function */
 
 };
 
Index: i386/libsaio/md5c.c
===================================================================
--- i386/libsaio/md5c.c	(.../vendor/132)	(revision 146)
+++ i386/libsaio/md5c.c	(.../branches/public)	(revision 146)
@@ -36,7 +36,11 @@
 #include <string.h>
 #endif
 
-#include <sys/md5.h>
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5
+# include <Kernel/libkern/crypto/md5.h>
+#else
+# include <sys/md5.h>
+#endif
 
 
 #ifdef KERNEL
@@ -157,7 +161,11 @@
 void
 MD5Update (context, input, inputLen)
 	MD5_CTX *context;
+#if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5
+	const void *input;
+#else
 	const unsigned char *input;
+#endif
 	unsigned int inputLen;
 {
 	unsigned int i, index, partLen;
@@ -180,7 +188,7 @@
 		MD5Transform (context->state, context->buffer);
 
 		for (i = partLen; i + 63 < inputLen; i += 64)
-			MD5Transform (context->state, &input[i]);
+			MD5Transform (context->state, &((const unsigned char *)input)[i]);
 
 		index = 0;
 	}
@@ -188,7 +196,7 @@
 		i = 0;
 
 	/* Buffer remaining input */
-	memcpy ((void *)&context->buffer[index], (const void *)&input[i],
+	memcpy ((void *)&context->buffer[index], (const void *)&((const unsigned char*)input)[i],
 	    inputLen-i);
 }
 
Index: i386/libsaio/fake_efi.c
===================================================================
--- i386/libsaio/fake_efi.c	(.../vendor/132)	(revision 0)
+++ i386/libsaio/fake_efi.c	(.../branches/public)	(revision 146)
@@ -0,0 +1,741 @@
+/*
+ * Copyright 2007 David F. Elliott.  All rights reserved.
+ */
+
+#include "libsaio.h"
+#include "bootstruct.h" /* for bootArgs */
+#include <pexpert/i386/efi.h>
+#include "fake_efi.h"
+#include "efi_tables.h"
+#include "SMBIOS.h"
+
+/*
+Modern Darwin kernels require some amount of EFI because Apple machines all
+have EFI.  Modifying the kernel source to not require EFI is of course
+possible but would have to be maintained as a separate patch because it is
+unlikely that Apple wishes to add legacy support to their kernel.
+
+As you can see from the Apple-supplied code in bootstruct.c, it seems that
+the intention was clearly to modify this booter to provide EFI-like structures
+to the kernel rather than modifying the kernel to handle non-EFI stuff.  This
+makes a lot of sense from an engineering point of view as it means the kernel
+for the as yet unreleased EFI-only Macs could still be booted by the non-EFI
+DTK systems so long as the kernel checked to ensure the boot tables were
+filled in appropriately.  Modern xnu requires a system table and a runtime
+services table and performs no checks whatsoever to ensure the pointers to
+these tables are non-NULL.  Therefore, any modern xnu kernel will page fault
+early on in the boot process if the system table pointer is zero.
+
+Even before that happens, the tsc_init function in modern xnu requires the FSB
+Frequency to be a property in the /efi/platform node of the device tree or else
+it panics the bootstrap process very early on.
+
+As of this writing, the current implementation found here is good enough
+to make the currently available xnu kernel boot without modification on a
+system with an appropriate processor.  With a minor source modification to
+the tsc_init function to remove the explicit check for Core or Core 2
+processors the kernel can be made to boot on other processors so long as
+the code can be executed by the processor and the machine contains the
+necessary hardware.
+*/
+
+
+/*==========================================================================
+ * Utility function to make a device tree string from an EFI_GUID
+ */
+
+static inline char * mallocStringForGuid(EFI_GUID const *pGuid)
+{
+    char *string = malloc(37);
+    efi_guid_unparse_upper(pGuid, string);
+    return string;
+}
+
+
+/*==========================================================================
+ * Fake EFI implementation
+ */
+
+/* Identify ourselves as the EFI firmware vendor */
+static EFI_CHAR16 const FIRMWARE_VENDOR[] = {'D','a','r','w','i','n','_','b','o','o','t', 0};
+static EFI_UINT32 const FIRMWARE_REVISION = 132; /* FIXME: Find a constant for this. */
+
+/* Just a ret instruction */
+static uint8_t const VOIDRET_INSTRUCTIONS[] = {0xc3};
+/* movl $0x80000003,%eax; ret */
+static uint8_t const UNSUPPORTEDRET_INSTRUCTIONS[] = {0xb8, 0x03, 0x00, 0x00, 0x80, 0xc3};
+
+/* Set up space for up to 10 configuration table entries */
+#define MAX_CONFIGURATION_TABLE_ENTRIES 10
+
+/* We use the fake_efi_pages struct so that we only need to do one kernel
+ * memory allocation for all needed EFI data.  Otherwise, small allocations
+ * like the FIRMWARE_VENDOR string would take up an entire page.
+ * NOTE WELL: Do NOT assume this struct has any particular layout within itself.
+ * It is absolutely not intended to be publicly exposed anywhere
+ * We say pages (plural) although right now we are well within the 1 page size
+ * and probably will stay that way.
+ */
+struct fake_efi_pages
+{
+    EFI_SYSTEM_TABLE efiSystemTable;
+    EFI_RUNTIME_SERVICES efiRuntimeServices;
+    EFI_CONFIGURATION_TABLE efiConfigurationTable[MAX_CONFIGURATION_TABLE_ENTRIES];
+    EFI_CHAR16 firmwareVendor[sizeof(FIRMWARE_VENDOR)/sizeof(EFI_CHAR16)];
+    uint8_t voidret_instructions[sizeof(VOIDRET_INSTRUCTIONS)/sizeof(uint8_t)];
+    uint8_t unsupportedret_instructions[sizeof(UNSUPPORTEDRET_INSTRUCTIONS)/sizeof(uint8_t)];
+};
+
+EFI_SYSTEM_TABLE *gST = NULL;
+Node *gEfiConfigurationTableNode = NULL;
+
+static EFI_STATUS addConfigurationTable(EFI_GUID const *pGuid, void *table, char const *alias)
+{
+    EFI_UINTN i = gST->NumberOfTableEntries;
+    /* We only do adds, not modifications and deletes like InstallConfigurationTable */
+    if(i >= MAX_CONFIGURATION_TABLE_ENTRIES)
+        stop("Ran out of space for configuration tables.  Increase the reserved size in the code.\n");
+
+    if(pGuid == NULL)
+        return EFI_INVALID_PARAMETER;
+
+    if(table != NULL)
+    {
+        gST->ConfigurationTable[i].VendorGuid = *pGuid;
+        gST->ConfigurationTable[i].VendorTable = table;
+
+        ++gST->NumberOfTableEntries;
+
+        Node *tableNode = DT__AddChild(gEfiConfigurationTableNode, mallocStringForGuid(pGuid));
+        /* Use the pointer to the GUID we just stuffed into the system table */
+        DT__AddProperty(tableNode, "guid", sizeof(EFI_GUID),&gST->ConfigurationTable[i].VendorGuid);
+	/* The "table" property is the 32-bit (in our implementation) physical address of the table */
+        DT__AddProperty(tableNode, "table", sizeof(void*), &gST->ConfigurationTable[i].VendorTable);
+        /* Assume the alias pointer is a global or static piece of data */
+        if(alias != NULL)
+            DT__AddProperty(tableNode, "alias", strlen(alias)+1, (char*)alias);
+        return EFI_SUCCESS;
+    }
+    return EFI_UNSUPPORTED;
+}
+
+static inline void fixupEfiSystemTableCRC32(EFI_SYSTEM_TABLE *efiSystemTable)
+{
+    efiSystemTable->Hdr.CRC32 = 0;
+    efiSystemTable->Hdr.CRC32 = crc32(0L, efiSystemTable, efiSystemTable->Hdr.HeaderSize);
+}
+
+/*
+What we do here is simply allocate a fake EFI system table and a fake EFI
+runtime services table.
+
+Because we build against modern headers with kBootArgsRevision 4 we
+also take care to set efiMode = 32.
+*/
+void
+setupEfiTables(void)
+{
+    struct fake_efi_pages *fakeEfiPages= (struct fake_efi_pages*)AllocateKernelMemory(sizeof(struct fake_efi_pages));
+
+    /* Zero out all the tables in case fields are added later */
+    bzero(fakeEfiPages, sizeof(struct fake_efi_pages));
+
+    /* --------------------------------------------------------------------
+     * Initialize some machine code that will return EFI_UNSUPPORTED for
+     * functions returning int and simply return for void functions.
+     */
+    memcpy(fakeEfiPages->voidret_instructions, VOIDRET_INSTRUCTIONS, sizeof(VOIDRET_INSTRUCTIONS));
+    memcpy(fakeEfiPages->unsupportedret_instructions, UNSUPPORTEDRET_INSTRUCTIONS, sizeof(UNSUPPORTEDRET_INSTRUCTIONS));
+
+    /* -------------------------------------------------------------------- */
+    /* System table */
+    EFI_SYSTEM_TABLE *efiSystemTable = gST = &fakeEfiPages->efiSystemTable;
+    efiSystemTable->Hdr.Signature = EFI_SYSTEM_TABLE_SIGNATURE;
+    efiSystemTable->Hdr.Revision = EFI_SYSTEM_TABLE_REVISION;
+    efiSystemTable->Hdr.HeaderSize = sizeof(EFI_SYSTEM_TABLE);
+    efiSystemTable->Hdr.CRC32 = 0; /* Initialize to zero and then do CRC32 */
+    efiSystemTable->Hdr.Reserved = 0;
+
+    efiSystemTable->FirmwareVendor = fakeEfiPages->firmwareVendor;
+    memcpy(efiSystemTable->FirmwareVendor, FIRMWARE_VENDOR, sizeof(FIRMWARE_VENDOR));
+    efiSystemTable->FirmwareRevision = FIRMWARE_REVISION;
+
+    /* XXX: We may need to have basic implementations of ConIn/ConOut/StdErr */
+    /* The EFI spec states that all handles are invalid after boot services have been
+     * exited so we can probably get by with leaving the handles as zero. */
+    efiSystemTable->ConsoleInHandle = 0;
+    efiSystemTable->ConIn = 0;
+
+    efiSystemTable->ConsoleOutHandle = 0;
+    efiSystemTable->ConOut = 0;
+
+    efiSystemTable->StandardErrorHandle = 0;
+    efiSystemTable->StdErr = 0;
+
+    efiSystemTable->RuntimeServices = &fakeEfiPages->efiRuntimeServices;
+    /* According to the EFI spec, BootServices aren't valid after the
+     * boot process is exited so we can probably do without it.
+     * Apple didn't provide a definition for it in pexpert/i386/efi.h
+     * so I'm guessing they don't use it.
+    */
+    efiSystemTable->BootServices = 0;
+
+    efiSystemTable->NumberOfTableEntries = 0;
+    efiSystemTable->ConfigurationTable = fakeEfiPages->efiConfigurationTable;
+
+
+    /* We're done.  Now CRC32 the thing so the kernel will accept it */
+    fixupEfiSystemTableCRC32(efiSystemTable);
+
+    /* -------------------------------------------------------------------- */
+    /* Runtime services */
+    EFI_RUNTIME_SERVICES *efiRuntimeServices = &fakeEfiPages->efiRuntimeServices;
+    efiRuntimeServices->Hdr.Signature = EFI_RUNTIME_SERVICES_SIGNATURE;
+    efiRuntimeServices->Hdr.Revision = EFI_RUNTIME_SERVICES_REVISION;
+    efiRuntimeServices->Hdr.HeaderSize = sizeof(EFI_RUNTIME_SERVICES);
+    efiRuntimeServices->Hdr.CRC32 = 0;
+    efiRuntimeServices->Hdr.Reserved = 0;
+
+    /* There are a number of function pointers in the efiRuntimeServices table.
+     * These are the Foundation (e.g. core) services and are expected to be present on
+     * all EFI-compliant machines.  Some kernel extensions (notably AppleEFIRuntime)
+     * will call these without checking to see if they are null.
+     *
+     * We don't really feel like doing an EFI implementation in the bootloader
+     * but it is nice if we can at least prevent a complete crash by
+     * at least providing some sort of implementation until one can be provided
+     * nicely in a kext.
+     */
+    void (*voidret_fp)() = (void*)fakeEfiPages->voidret_instructions;
+    void (*unsupportedret_fp)() = (void*)fakeEfiPages->unsupportedret_instructions;
+    efiRuntimeServices->GetTime = (void*)unsupportedret_fp;
+    efiRuntimeServices->SetTime = (void*)unsupportedret_fp;
+    efiRuntimeServices->GetWakeupTime = (void*)unsupportedret_fp;
+    efiRuntimeServices->SetWakeupTime = (void*)unsupportedret_fp;
+    efiRuntimeServices->SetVirtualAddressMap = (void*)unsupportedret_fp;
+    efiRuntimeServices->ConvertPointer = (void*)unsupportedret_fp;
+    efiRuntimeServices->GetVariable = (void*)unsupportedret_fp;
+    efiRuntimeServices->GetNextVariableName = (void*)unsupportedret_fp;
+    efiRuntimeServices->SetVariable = (void*)unsupportedret_fp;
+    efiRuntimeServices->GetNextHighMonotonicCount = (void*)unsupportedret_fp;
+    efiRuntimeServices->ResetSystem = (void*)voidret_fp;
+
+    /* We're done.  Now CRC32 the thing so the kernel will accept it */
+    efiRuntimeServices->Hdr.CRC32 = crc32(0L, efiRuntimeServices, efiRuntimeServices->Hdr.HeaderSize);
+
+
+    /* -------------------------------------------------------------------- */
+    /* Finish filling in the rest of the boot args that we need. */
+    bootArgs->efiSystemTable = (uint32_t)efiSystemTable;
+    bootArgs->efiMode = kBootArgsEfiMode32;
+
+    /* The bootArgs structure as a whole is bzero'd so we don't need to fill in
+     * things like efiRuntimeServices* and what not.
+     *
+     * In fact, the only code that seems to use that is the hibernate code so it
+     * knows not to save the pages.  It even checks to make sure its nonzero.
+     */
+}
+
+/*
+In addition to the EFI tables there is also the EFI device tree node.
+In particular, we need /efi/platform to have an FSBFrequency key. Without it,
+the tsc_init function will panic very early on in kernel startup, before
+the console is available.
+*/
+
+/* Decimal powers: */
+#define kilo (1000ULL)
+#define Mega (kilo * kilo)
+#define Giga (kilo * Mega)
+#define Tera (kilo * Giga)
+#define Peta (kilo * Tera)
+
+/*==========================================================================
+ * FSB Frequency detection
+ */
+// DFE: rdtsc64 from xnu (obvious implementation)
+static inline uint64_t rdtsc64(void)
+{
+    uint64_t ret;
+    __asm__ volatile("rdtsc" : "=A" (ret));
+    return ret;
+}
+
+// DFE: enable_PIT2 and disable_PIT2 come from older xnu
+
+/*
+ * Enable or disable timer 2.
+ * Port 0x61 controls timer 2:
+ *   bit 0 gates the clock,
+ *   bit 1 gates output to speaker.
+ */
+inline static void
+enable_PIT2(void)
+{
+    /* Enable gate, disable speaker */
+    __asm__ volatile(
+        " inb   $0x61,%%al      \n\t"
+        " and   $0xFC,%%al       \n\t"  /* & ~0x03 */
+        " or    $1,%%al         \n\t"
+        " outb  %%al,$0x61      \n\t"
+        : : : "%al" );
+}
+
+inline static void
+disable_PIT2(void)
+{
+    /* Disable gate and output to speaker */
+    __asm__ volatile(
+        " inb   $0x61,%%al      \n\t"
+        " and   $0xFC,%%al      \n\t"	/* & ~0x03 */
+        " outb  %%al,$0x61      \n\t"
+        : : : "%al" );
+}
+
+// DFE: set_PIT2_mode0, poll_PIT2_gate, and measure_tsc_frequency are
+// roughly based on Linux code
+
+/* Set the 8254 channel 2 to mode 0 with the specified value.
+   In mode 0, the counter will initially set its gate low when the
+   timer expires.  For this to be useful, you ought to set it high
+   before calling this function.  The enable_PIT2 function does this.
+ */
+static inline void set_PIT2_mode0(uint16_t value)
+{
+    __asm__ volatile(
+        " movb  $0xB0,%%al      \n\t"
+        " outb	%%al,$0x43	\n\t"
+        " movb	%%dl,%%al	\n\t"
+        " outb	%%al,$0x42	\n\t"
+        " movb	%%dh,%%al	\n\t"
+        " outb	%%al,$0x42"
+        : : "d"(value) /*: no clobber */ );
+}
+
+/* Returns the number of times the loop ran before the PIT2 signaled */
+static inline unsigned long poll_PIT2_gate(void)
+{
+    unsigned long count = 0;
+    unsigned char nmi_sc_val;
+    do {
+        ++count;
+        __asm__ volatile(
+            "inb	$0x61,%0"
+        : "=q"(nmi_sc_val) /*:*/ /* no input */ /*:*/ /* no clobber */);
+    } while( (nmi_sc_val & 0x20) == 0);
+    return count;
+}
+
+// DFE: This constant comes from older xnu:
+#define CLKNUM		1193182		/* formerly 1193167 */
+
+// DFE: These two constants come from Linux except CLOCK_TICK_RATE replaced with CLKNUM
+#define CALIBRATE_TIME_MSEC 30 /* 30 msecs */
+#define CALIBRATE_LATCH	\
+	((CLKNUM * CALIBRATE_TIME_MSEC + 1000/2)/1000)
+
+/*
+ * Measures the TSC frequency in Hz (64-bit) using the ACPI PM timer
+ */
+uint64_t measure_tsc_frequency(void);
+uint64_t measure_tsc_frequency(void)
+{
+    uint64_t tscStart;
+    uint64_t tscEnd;
+    uint64_t tscDelta = 0xffffffffffffffffULL;
+    unsigned long pollCount;
+    uint64_t retval = 0;
+    int i;
+
+    /* Time how many TSC ticks elapse in 30 msec using the 8254 PIT
+     * counter 2.  We run this loop 3 times to make sure the cache
+     * is hot and we take the minimum delta from all of the runs.
+     * That is to say that we're biased towards measuring the minimum
+     * number of TSC ticks that occur while waiting for the timer to
+     * expire.  That theoretically helps avoid inconsistencies when
+     * running under a VM if the TSC is not virtualized and the host
+     * steals time.  The TSC is normally virtualized for VMware.
+     */
+    for(i = 0; i < 3; ++i)
+    {
+        enable_PIT2();
+        set_PIT2_mode0(CALIBRATE_LATCH);
+        tscStart = rdtsc64();
+        pollCount = poll_PIT2_gate();
+        tscEnd = rdtsc64();
+        /* The poll loop must have run at least a few times for accuracy */
+        if(pollCount <= 1)
+            continue;
+        /* The TSC must increment at LEAST once every millisecond.  We
+         * should have waited exactly 30 msec so the TSC delta should
+         * be >= 30.  Anything less and the processor is way too slow.
+         */
+        if((tscEnd - tscStart) <= CALIBRATE_TIME_MSEC)
+            continue;
+        // tscDelta = min(tscDelta, (tscEnd - tscStart))
+        if( (tscEnd - tscStart) < tscDelta )
+            tscDelta = tscEnd - tscStart;
+    }
+    /* tscDelta is now the least number of TSC ticks the processor made in
+     * a timespan of 0.03 s (e.g. 30 milliseconds)
+     * Linux thus divides by 30 which gives the answer in kiloHertz because
+     * 1 / ms = kHz.  But we're xnu and most of the rest of the code uses
+     * Hz so we need to convert our milliseconds to seconds.  Since we're
+     * dividing by the milliseconds, we simply multiply by 1000.
+     */
+
+    /* Unlike linux, we're not limited to 32-bit, but we do need to take care
+     * that we're going to multiply by 1000 first so we do need at least some
+     * arithmetic headroom.  For now, 32-bit should be enough.
+     * Also unlike Linux, our compiler can do 64-bit integer arithmetic.
+     */
+    if(tscDelta > (1ULL<<32))
+        retval = 0;
+    else
+    {
+        retval = tscDelta * 1000 / 30;
+    }
+    disable_PIT2();
+    return retval;
+}
+
+static inline uint64_t rdmsr64(uint32_t msr)
+{
+	uint64_t ret;
+	__asm__ volatile("rdmsr" : "=A" (ret) : "c" (msr));
+	return ret;
+}
+
+#define MSR_IA32_PERF_STS		0x198
+
+#define bit(n)		(1ULL << (n))
+#define bitmask(h,l)	((bit(h)|(bit(h)-1)) & ~(bit(l)-1))
+#define bitfield(x,h,l)	(((x) & bitmask(h,l)) >> l)
+
+uint64_t fsbFrequency = 0;
+
+void determineFsbFrequency()
+{
+    const char *val; // value
+    int cnt; // length of value
+
+    if(getValueForKey("fsbmhz", &val, &cnt))
+    {
+        uint32_t fsbmhz;
+        char valcpy[10];
+        bool gotvalue = (cnt < 10);
+        if(gotvalue)
+        {
+            // Force NUL-term by making a copy with strlcpy
+            strlcpy(valcpy, val, cnt+1);
+            char *endval;
+            fsbmhz = strtoul(valcpy, &endval, 10);
+            gotvalue = (valcpy != endval && *endval == '\0');
+        }
+        if(gotvalue)
+        {
+            switch(fsbmhz)
+            {
+            case 33:
+                fsbFrequency =  33333333;
+                break;
+            case 66:
+                fsbFrequency =  66666667;
+                break;
+            case 133:
+                fsbFrequency = 133333333;
+                break;
+            case 166:
+                fsbFrequency = 166666667;
+                break;
+            default:
+                printf("Strange fsbmhz=%d specified.. assuming you mean it literally.\n", fsbmhz);
+                /* Fall through */
+            case 100:
+            case 200:
+                fsbFrequency = fsbmhz * Mega;
+            }
+        }
+        else
+            fsbFrequency = 0;
+    }
+    else
+        fsbFrequency = 0;
+
+    if(fsbFrequency != 0)
+    {
+        printf("Using specified FSB Frequency %d.%06dMHz\n", (uint32_t)(fsbFrequency/Mega), (uint32_t)(fsbFrequency % Mega));
+        sleep(1);
+        return;
+    }
+    printf("Attempting to determine CPU Multiplier.  If system reboots, RDMSR 198h causes a fault.\n");
+    sleep(1);
+    uint64_t prfsts = rdmsr64(MSR_IA32_PERF_STS);
+    uint32_t tscGranularity = bitfield(prfsts, 44, 40);
+    printf("Determined CPU:FSB multiplier to be %d\n", tscGranularity);
+    if(tscGranularity == 0)
+    {
+        printf("CPU says its multiplier is 0 which makes no sense. The kernel as shipped by\n");
+        printf("Apple will not support this and will cause the machine to reboot immediately.\n");
+        printf("Press 'y' to continue or use Ctrl+Alt+Delete to reboot\n");
+        while(getc() != 'y')
+            ;
+        fsbFrequency = 0;
+        return;
+    }
+    printf("Measuring TSC frequency (e.g. CPU speed)\n");
+    uint64_t measuredTscFrequency = measure_tsc_frequency();
+    printf("CPU runs at %d.%06d MHz\n", (uint32_t)(measuredTscFrequency / Mega), (uint32_t)(measuredTscFrequency % Mega));
+    fsbFrequency = measuredTscFrequency / tscGranularity;
+    printf("BUS must therefore run at %d.%06d MHz\n", (uint32_t)(fsbFrequency / Mega), (uint32_t)(fsbFrequency % Mega));
+    sleep(1);
+}
+
+void printFrequencyInfo()
+{
+    printf("\n");
+    uint64_t measuredTscFrequency = measure_tsc_frequency();
+    printf("CPU runs at %d.%06d MHz\n", (uint32_t)(measuredTscFrequency / Mega), (uint32_t)(measuredTscFrequency % Mega));
+    printf("\n");
+    printf("(Press a key to continue...)");
+    getc();
+}
+
+/* This should be const but DT__AddProperty takes char* */
+static char FSB_Frequency_prop[] = "FSBFrequency";
+
+
+/*==========================================================================
+ * SMBIOS
+ */
+
+/* From Foundation/Efi/Guid/Smbios/SmBios.h */
+/* Modified to wrap Data4 array init with {} */
+#define EFI_SMBIOS_TABLE_GUID \
+  { \
+    0xeb9d2d31, 0x2d88, 0x11d3, {0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d} \
+  }
+
+/* From Foundation/Efi/Guid/Smbios/SmBios.c */
+EFI_GUID const  gEfiSmbiosTableGuid = EFI_SMBIOS_TABLE_GUID;
+
+#define SMBIOS_RANGE_START      0x000F0000
+#define SMBIOS_RANGE_END        0x000FFFFF
+
+/* '_SM_' in little endian: */
+#define SMBIOS_ANCHOR_UINT32_LE 0x5f4d535f
+
+static inline void* getAddressOfSmbiosTable()
+{
+    /* First see if we can even find the damn SMBIOS table
+     * The logic here is to start at 0xf0000 and end at 0xfffff iterating 16 bytes at a time looking
+     * for the SMBIOS entry-point structure anchor (literal ASCII "_SM_").
+     */
+    void *smbios_addr = (void*)SMBIOS_RANGE_START;
+    for(; (smbios_addr <= (void*)SMBIOS_RANGE_END) && (*(uint32_t*)smbios_addr != SMBIOS_ANCHOR_UINT32_LE); smbios_addr += 16)
+        ;
+    if(smbios_addr <= (void*)SMBIOS_RANGE_END)
+    {
+        /* NOTE: The specification does not specifically state what to do in the event of finding an
+         * SMBIOS anchor on an invalid table.  It might be better to move this code into the for loop
+         * so that searching can continue.
+         */
+        uint8_t csum = checksum8(smbios_addr, sizeof(struct SMBEntryPoint));
+        /* The table already contains the checksum so we merely need to see if its checksum is now zero. */
+        if(csum != 0)
+        {
+            printf("Found SMBIOS anchor but bad table checksum.  Assuming no SMBIOS.\n");
+            sleep(5);
+            smbios_addr = 0;
+        }
+    }
+    else
+    {
+        /* If this happens, it's possible that a PnP BIOS call can be done to retrieve the address of the table.
+         * The latest versions of the spec state that modern programs should not even attempt to do this. */
+        printf("Unable to find SMBIOS table.\n");
+        sleep(5);
+        smbios_addr = 0;
+    }
+    return smbios_addr;
+}
+
+
+/*==========================================================================
+ * ACPI
+ */
+
+#define EFI_ACPI_TABLE_GUID \
+  { \
+    0xeb9d2d30, 0x2d88, 0x11d3, { 0x9a, 0x16, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d } \
+  }
+
+#define EFI_ACPI_20_TABLE_GUID \
+  { \
+    0x8868e871, 0xe4f1, 0x11d3, { 0xbc, 0x22, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 } \
+  }
+
+// NOTE: ACPI 3.0 uses same GUID as ACPI 2.0
+
+EFI_GUID  gEfiAcpiTableGuid = EFI_ACPI_TABLE_GUID;
+
+EFI_GUID  gEfiAcpi20TableGuid = EFI_ACPI_20_TABLE_GUID;
+
+#define ACPI_RANGE_START    (0x0E0000)
+#define ACPI_RANGE_END      (0x0FFFFF)
+
+#define UINT64_LE_FROM_CHARS(a,b,c,d,e,f,g,h) \
+    (   ((uint64_t)h << 56) \
+    |   ((uint64_t)g << 48) \
+    |   ((uint64_t)f << 40) \
+    |   ((uint64_t)e << 32) \
+    |   ((uint64_t)d << 24) \
+    |   ((uint64_t)c << 16) \
+    |   ((uint64_t)b <<  8) \
+    |   ((uint64_t)a <<  0) \
+    )
+
+#define ACPI_SIGNATURE_UINT64_LE UINT64_LE_FROM_CHARS('R','S','D',' ','P','T','R',' ')
+
+/* Per ACPI 3.0a spec */
+struct acpi_2_rsdp {
+    char            Signature[8];
+    uint8_t         Checksum;
+    char            OEMID[6];
+    uint8_t         Revision;
+    uint32_t        RsdtAddress;
+    uint32_t        Length;
+    uint64_t        XsdtAddress;
+    uint8_t         ExtendedChecksum;
+    char            Reserved[3];
+} __attribute__((packed));
+
+/* Gets the ACPI 1.0 RSDP address */
+static void* getAddressOfAcpiTable()
+{
+    /* TODO: Before searching the BIOS space we are supposed to search the first 1K of the EBDA */
+
+    void *acpi_addr = (void*)ACPI_RANGE_START;
+    for(; acpi_addr <= (void*)ACPI_RANGE_END; acpi_addr += 16)
+    {
+        if(*(uint64_t *)acpi_addr == ACPI_SIGNATURE_UINT64_LE)
+        {
+            uint8_t csum = checksum8(acpi_addr, 20);
+            if(csum == 0)
+            {
+                // Only return the table if it is a true version 1.0 table (Revision 0)
+                if(((struct acpi_2_rsdp*)acpi_addr)->Revision == 0)
+                    return acpi_addr;
+            }
+        }
+    }
+    return NULL;
+}
+
+/* Gets the ACPI 2.0 RSDP address */
+static void* getAddressOfAcpi20Table()
+{
+    /* TODO: Before searching the BIOS space we are supposed to search the first 1K of the EBDA */
+
+    void *acpi_addr = (void*)ACPI_RANGE_START;
+    for(; acpi_addr <= (void*)ACPI_RANGE_END; acpi_addr += 16)
+    {
+        if(*(uint64_t *)acpi_addr == ACPI_SIGNATURE_UINT64_LE)
+        {
+            uint8_t csum = checksum8(acpi_addr, 20);
+            /* Only assume this is a 2.0 or better table if the revision is greater than 0
+             * NOTE: ACPI 3.0 spec only seems to say that 1.0 tables have revision 1
+             * and that the current revision is 2.. I am going to assume that rev > 0 is 2.0.
+             */
+            if(csum == 0 && (((struct acpi_2_rsdp*)acpi_addr)->Revision > 0))
+            {
+                uint8_t csum2 = checksum8(acpi_addr, sizeof(struct acpi_2_rsdp));
+                if(csum2 == 0)
+                    return acpi_addr;
+            }
+        }
+    }
+    return NULL;
+}
+
+
+/*==========================================================================
+ * Fake EFI implementation
+ */
+
+char const FIRMWARE_REVISION_PROP[] = "firmware-revision";
+char const FIRMWARE_ABI_PROP[] = "firmware-abi";
+char const FIRMWARE_VENDOR_PROP[] = "firmware-vendor";
+char const FIRMWARE_ABI_PROP_VALUE[] = "EFI32";
+
+void
+setupEfiDeviceTree(void)
+{
+    Node *node;
+    node = DT__FindNode("/", false);
+    if (node == 0) {
+        stop("Couldn't get root node");
+    }
+    /* We could also just do DT__FindNode("/efi/platform", true)
+     * But I think eventually we want to fill stuff in the efi node
+     * too so we might as well create it so we have a pointer for it too.
+    */
+    node = DT__AddChild(node, "efi");
+
+    DT__AddProperty(node, FIRMWARE_REVISION_PROP, sizeof(FIRMWARE_REVISION), (EFI_UINT32*)&FIRMWARE_REVISION);
+    DT__AddProperty(node, FIRMWARE_ABI_PROP, sizeof(FIRMWARE_ABI_PROP_VALUE), (char*)FIRMWARE_ABI_PROP_VALUE);
+    DT__AddProperty(node, FIRMWARE_VENDOR_PROP, sizeof(FIRMWARE_VENDOR), (EFI_CHAR16*)FIRMWARE_VENDOR);
+
+    /* TODO: Fill in other efi properties if necessary */
+
+    /* Set up the /efi/runtime-services table node similar to the way a child node of configuration-table
+     * is set up.  That is, name and table properties */
+    Node *runtimeServicesNode = DT__AddChild(node, "runtime-services");
+
+    /* The value of the table property is the 32-bit physical address for the RuntimeServices table.
+     * Sice the EFI system table already has a pointer to it, we simply use the address of that pointer
+     * for the pointer to the property data.  Warning.. DT finalization calls free on that but we're not
+     * the only thing to use a non-malloc'd pointer for something in the DT
+     */
+    DT__AddProperty(runtimeServicesNode, "table", sizeof(void *), &gST->RuntimeServices);
+
+    /* Set up the /efi/configuration-table node which will eventually have several child nodes for
+     * all of the configuration tables needed by various kernel extensions.
+     */
+    gEfiConfigurationTableNode = DT__AddChild(node, "configuration-table");
+
+    /* Now fill in the /efi/platform Node */
+    Node *efiPlatformNode = DT__AddChild(node, "platform");
+
+    if(fsbFrequency != 0)
+        DT__AddProperty(efiPlatformNode, FSB_Frequency_prop, sizeof(uint64_t), &fsbFrequency);
+    /* NOTE WELL: If you do add FSB Frequency detection, make sure to store
+     * the value in the fsbFrequency global and not an malloc'd pointer
+     * because the DT_AddProperty function does not copy its args.
+     */
+}
+
+/* Installs all the needed configuration table entries */
+void setupEfiConfigurationTable()
+{
+    addConfigurationTable(&gEfiSmbiosTableGuid, getAddressOfSmbiosTable(), NULL);
+    addConfigurationTable(&gEfiAcpiTableGuid, getAddressOfAcpiTable(), "ACPI");
+    addConfigurationTable(&gEfiAcpi20TableGuid, getAddressOfAcpi20Table(), "ACPI_20");
+
+    // We've obviously changed the count.. so fix up the CRC32
+    fixupEfiSystemTableCRC32(gST);
+}
+
+/* Entrypoint from boot.c */
+void setupFakeEfi(void)
+{
+    determineFsbFrequency();
+    // Initialize the base table
+    setupEfiTables();
+    // Initialize the device tree
+    setupEfiDeviceTree();
+    // Add configuration table entries to both the services table and the device tree
+    setupEfiConfigurationTable();
+}
+
Index: i386/libsaio/misc.c
===================================================================
--- i386/libsaio/misc.c	(.../vendor/132)	(revision 146)
+++ i386/libsaio/misc.c	(.../branches/public)	(revision 146)
@@ -71,29 +71,41 @@
 //==========================================================================
 // Enable A20 gate to be able to access memory above 1MB
 
+static inline void flushKeyboardInputBuffer()
+{
+    unsigned char ret;
+    /* Apparently all flags on means that they're invalid and that the code
+       should stop trying to check them because they'll never change */
+    do
+    {
+        ret = inb(PORT_B);
+    } while( (ret != 0xff) && (ret & KB_INFULL));
+}
+
 void enableA20()
 {
     /* make sure that the input buffer is empty */
-    while (inb(PORT_B) & KB_INFULL);
+    flushKeyboardInputBuffer();
 
     /* make sure that the output buffer is empty */
     if (inb(PORT_B) & KB_OUTFULL)
         (void)inb(PORT_A);
 
     /* make sure that the input buffer is empty */
-    while (inb(PORT_B) & KB_INFULL);
+    flushKeyboardInputBuffer();
 
     /* write output port */
     outb(PORT_B, CMD_WOUT);
     delay(100);
 
     /* wait until command is accepted */
-    while (inb(PORT_B) & KB_INFULL);
+    flushKeyboardInputBuffer();
 
     outb(PORT_A, KB_A20);
     delay(100);
 
-    while (inb(PORT_B) & KB_INFULL);   /* wait until done */
+    /* wait until done */
+    flushKeyboardInputBuffer();
 }
 
 static inline void
Index: i386/libsaio/saio_internal.h
===================================================================
--- i386/libsaio/saio_internal.h	(.../vendor/132)	(revision 146)
+++ i386/libsaio/saio_internal.h	(.../branches/public)	(revision 146)
@@ -46,6 +46,7 @@
 extern int    ebiosread(int dev, long sec, int count);
 extern int    ebioswrite(int dev, long sec, int count);
 extern int    get_drive_info(int drive, struct driveInfo *dp);
+extern int ebiosEjectMedia(int biosdev);
 extern void   putc(int ch);
 extern void   putca(int ch, int attr, int repeat);
 extern int    getc(void);
@@ -73,12 +74,13 @@
 extern void   sleep(int n);
 
 /* bootstruct.c */
-extern void   initKernBootStruct(int biosdev);
+extern void   initKernBootStruct(void);
 extern void   reserveKernBootStruct(void);
 extern void   copyKernBootStruct(void);
 extern void   finalizeBootStruct(void);
 
 /* cache.c */
+extern void CacheReset();
 extern void   CacheInit(CICell ih, long blockSize);
 extern long   CacheRead(CICell ih, char *buffer, long long offset,
                         long length, long cache);
@@ -94,6 +96,8 @@
 extern void   stop(const char *format, ...);
 
 /* disk.c */
+extern struct DiskBVMap* diskResetBootVolumes(int biosdev);
+extern void diskFreeMap(struct DiskBVMap *map);
 extern BVRef  diskScanBootVolumes(int biosdev, int *count);
 extern void   diskSeek(BVRef bvr, long long position);
 extern int    diskRead(BVRef bvr, long addr, long length);
@@ -162,7 +166,6 @@
 extern int    read(int fdesc, char *buf, int count);
 extern int    b_lseek(int fdesc, int addr, int ptr);
 extern int    tell(int fdesc);
-extern const char * usrDevices(void);
 extern const char * systemConfigDir(void);
 extern struct dirstuff * opendir(const char *path);
 extern struct dirstuff * vol_opendir(BVRef bvr, const char *path);
@@ -171,13 +174,18 @@
 extern int    readdir_ext(struct dirstuff * dirp, const char ** name, long * flags,
                           long * time, FinderInfo *finderInfo, long *infoValid);
 extern void   flushdev(void);
-extern int    currentdev(void);
-extern int    switchdev(int dev);
 extern BVRef  scanBootVolumes(int biosdev, int *count);
 extern BVRef  selectBootVolume(BVRef chain);
 extern void   getBootVolumeDescription(BVRef bvr, char *str, long strMaxLen, BOOL verbose);
+extern void setRootVolume(BVRef volume);
 
 extern int gBIOSDev;
 extern int gBootFileType;
 
+// Function pointer to be filled in if ramdisks are available
+extern int (*p_get_ramdisk_info)(int biosdev, struct driveInfo *dip);
+extern int (*p_ramdiskReadBytes)( int biosdev, unsigned int blkno,
+                      unsigned int byteoff,
+                      unsigned int byteCount, void * buffer );
+
 #endif /* !__LIBSAIO_SAIO_INTERNAL_H */
Index: i386/MakeInc.dir
===================================================================
--- i386/MakeInc.dir	(.../vendor/132)	(revision 146)
+++ i386/MakeInc.dir	(.../branches/public)	(revision 146)
@@ -12,6 +12,14 @@
   MKDIRS = /bin/mkdir -p
 endif
 
+# Toggle this as to whether you want a frame pointer (%ebp) to be used. It is
+# invaluable for debugging the booter. For example using GDB attached to VMware.
+# In fact, it's so invaluable that it's now the default.  Not only that but the
+# compiler seems to generate slightly smaller code and the real<->prot code
+# clearly handles it appropriately so I have no idea why Apple omitted it.
+#OMIT_FRAME_POINTER_CFLAG=-fomit-frame-pointer
+OMIT_FRAME_POINTER_CFLAG=
+
 installsrc:: $(SRCROOT)
 	cp $(ALLSRC) $(SRCROOT)
 	cd $(SRCROOT); chmod a-w $(ALLSRC)
@@ -35,17 +43,17 @@
 .SUFFIXES: .s .i .c .o
 
 .c.o .m.o:
-	$(CC) $(CFLAGS) $(DEFINES) -c $(INC) $< -o $(OBJROOT)/$*.o \
+	$(CC) $(CPPFLAGS) $(CFLAGS) $(DEFINES) -c $(INC) $< -o $(OBJROOT)/$*.o \
 	    -MD -dependency-file $(OBJROOT)/$*.d
 	md -u $(OBJROOT)/Makedep -f -d $(OBJROOT)/$*.d
 
 $(OBJROOT)/%.o: %.c
-	$(CC) $(CFLAGS) $(DEFINES) -c $(INC) $< -o $(OBJROOT)/$*.o \
+	$(CC) $(CPPFLAGS) $(CFLAGS) $(DEFINES) -c $(INC) $< -o $(OBJROOT)/$*.o \
 	    -MD -dependency-file $(OBJROOT)/$*.d
 	md -u $(OBJROOT)/Makedep -f -d $(OBJROOT)/$*.d
 
 $(OBJROOT)/%.o: %.m
-	$(CC) $(CFLAGS) $(DEFINES) -c $(INC) $< -o $(OBJROOT)/$*.o \
+	$(CC) $(CPPFLAGS) $(CFLAGS) $(DEFINES) -c $(INC) $< -o $(OBJROOT)/$*.o \
 	    -MD -dependency-file $(OBJROOT)/$*.d
 	md -u $(OBJROOT)/Makedep -f -d $(OBJROOT)/$*.d
 
@@ -54,10 +62,10 @@
 #	$(AS) -o $(OBJROOT)/$@ $(OBJROOT)/$*.o2
 
 .s.o:
-	cc -c $(INC) -arch i386 -o $(OBJROOT)/$(@F) $<
+	cc $(CPPFLAGS) -c $(INC) -arch i386 -o $(OBJROOT)/$(@F) $<
 	
 $(OBJROOT)/%.o: %.s
-	cc -c $(INC) -arch i386 -o $(OBJROOT)/$(@F) $<
+	cc $(CPPFLAGS) -c $(INC) -arch i386 -o $(OBJROOT)/$(@F) $<
 
 $(DIRS_NEEDED) $(INSTALLDIR) $(SRCROOT):
 	$(MKDIRS) $@
Index: i386/boot2/graphics.c
===================================================================
--- i386/boot2/graphics.c	(.../vendor/132)	(revision 146)
+++ i386/boot2/graphics.c	(.../branches/public)	(revision 146)
@@ -626,7 +626,8 @@
 static void
 setBorderColor( unsigned char  colorIndex )
 {
-    long   color = lookUpCLUTIndex( colorIndex, 32 );
+    // There is no implementation anymore so no need to look up the color.
+//    long   color = lookUpCLUTIndex( colorIndex, 32 );
     VBEInfoBlock     vbeInfo;
     int              err;
 
Index: i386/boot2/boot.c
===================================================================
--- i386/boot2/boot.c	(.../vendor/132)	(revision 146)
+++ i386/boot2/boot.c	(.../branches/public)	(revision 146)
@@ -52,6 +52,7 @@
 
 #include "boot.h"
 #include "bootstruct.h"
+#include "fake_efi.h"
 #include "sl.h"
 #include "libsa.h"
 
@@ -65,6 +66,8 @@
 char gMKextName[512];
 BVRef gBootVolume;
 
+static void selectBiosDevice(void);
+
 static
 unsigned long Adler32(unsigned char *buffer, long length);
 
@@ -107,6 +110,17 @@
     asm volatile ("hlt");
 }
 
+/*!
+    Initializes the runtime.  Right now this means zeroing the BSS and initializing malloc.
+ */
+void initialize_runtime()
+{
+    zeroBSS();
+
+    // Initialize malloc
+    malloc_init(0, 0, 0, malloc_error);
+}
+
 //==========================================================================
 // execKernel - Load the kernel image (mach-o) and jump to its entry point.
 
@@ -143,6 +157,8 @@
         sleep(kBootErrorTimeout);
     }
 
+    setupFakeEfi();
+
     printf("Starting Darwin/x86");
 
     // Cleanup the PXE base code.
@@ -207,6 +223,21 @@
     // PCI_Bus_Init( &bootInfo->pciInfo );
 }
 
+/*!
+    This is the entrypoint from real-mode which functions exactly as it did before.
+    Multiboot does its own runtime initialization, does some of its own things, and then
+    calls common_boot.
+ */
+void boot(int biosdev)
+{
+    initialize_runtime();
+
+    // Enable A20 gate before accessing memory above 1Mb.
+    enableA20();
+
+    return common_boot(biosdev);
+}
+
 //==========================================================================
 // The 'main' function for the booter. Called by boot0 when booting
 // from a block device, or by the network booter.
@@ -221,7 +252,7 @@
 
 #define DLOG(x) outb(0x80, (x))
 
-void boot(int biosdev)
+void common_boot(int biosdev)
 {
     int      status;
     char     *bootFile;
@@ -230,15 +261,6 @@
     BOOL     firstRun = YES;
     BVRef    bvChain;
 
-    zeroBSS();
-
-    // Initialize malloc
-    malloc_init(0, 0, 0, malloc_error);
-
-    // Enable A20 gate before accessing memory above 1Mb.
-
-    enableA20();
-
     // Set reminder to unload the PXE base code. Neglect to unload
     // the base code will result in a hang or kernel panic.
 
@@ -250,7 +272,7 @@
 
     // Initialize boot info structure.
 
-    initKernBootStruct( gBIOSDev );
+    initKernBootStruct();
 
     // Setup VGA text mode.
     // Not sure if it is safe to call setVideoMode() before the
@@ -267,7 +289,7 @@
     // Check to see that this hardware is supported.
     status = checkForSupportedHardware();
     if (status != 0) {
-        stop("This hardware configuration is not supported by Darwin/x86. (%d)", status);
+        printf("This hardware configuration is not supported by Darwin/x86. (%d)", status);
     }
 
     // Scan hardware configuration.
@@ -278,9 +300,7 @@
 
     // Record default boot device.
     gBootVolume = selectBootVolume(bvChain);
-    bootInfo->kernDev = MAKEKERNDEV(gBIOSDev,
-                                    BIOS_DEV_UNIT(gBootVolume),
-                                    gBootVolume->part_no );
+    setRootVolume(gBootVolume);
 
     // Load default config file from boot device.
     status = loadSystemConfig(0, 0);
@@ -310,8 +330,17 @@
         if (status == -1) continue;
 
         status = processBootOptions();
+        // Status==1 means to chainboot
         if ( status ==  1 ) break;
-        if ( status == -1 ) continue;
+        // Status==-1 means that the config file couldn't be loaded or that gBootVolume is NULL
+        if ( status == -1 )
+        {
+            // gBootVolume == NULL usually means the user hit escape.
+            if(gBootVolume == NULL)
+                selectBiosDevice();
+            continue;
+        }
+        // Other status (e.g. 0) means that we should proceed with boot.
 
         // Found and loaded a config file. Proceed with boot.
 
@@ -410,6 +439,25 @@
     }
 }
 
+/*!
+    Selects a new BIOS device, taking care to update the global state appropriately.
+ */
+static void selectBiosDevice(void)
+{
+    struct DiskBVMap *oldMap = diskResetBootVolumes(gBIOSDev);
+    CacheReset();
+    diskFreeMap(oldMap);
+    oldMap = NULL;
+
+    int dev = selectAlternateBootDevice(gBIOSDev);
+
+    BVRef bvchain = scanBootVolumes(dev, 0);
+    BVRef bootVol = selectBootVolume(bvchain);
+    gBootVolume = bootVol;
+    setRootVolume(bootVol);
+    gBIOSDev = dev;
+}
+
 #define BASE 65521L /* largest prime smaller than 65536 */
 #define NMAX 5000
 // NMAX (was 5521) the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1
Index: i386/boot2/boot2.s
===================================================================
--- i386/boot2/boot2.s	(.../vendor/132)	(revision 146)
+++ i386/boot2/boot2.s	(.../branches/public)	(revision 146)
@@ -38,6 +38,7 @@
 
 #include <architecture/i386/asm_help.h>
 #include "memory.h"
+#include "mboot.h"
 
 #define data32  .byte 0x66
 #define retf    .byte 0xcb
@@ -124,3 +125,217 @@
 
     data32
     ljmp    $0, $0x7c00         # Jump to boot code already in memory
+
+
+# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+# Multiboot support added by David F. Elliott <dfe@cox.net> on 2007/06/26
+# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+# Multiboot section
+# The above is used when booting with the normal booter (boot1h/boot1u).
+# The following is used when booting with a multiboot capable loader such as grub
+# Unlike the normal booter which starts in real mode, we start in protected mode
+
+# Unforuntately, GRUB refuses to load a multiboot "kernel" below 1MB.
+# This is basically due to the fact that GRUB likes to live below 1MB because
+# it starts up in real mode just like we would normally be starting up if
+# we weren't being Multiboot loaded by GRUB.
+# Therefore, we must tell our loader to load us above 1MB.  To make it easy,
+# we simply specify exactly 1 MB higher than we want.
+# This means of course that when we enter we are not where the assembler
+# and linker expect us to be.  Please remember this when modifying code.
+#define OFFSET_1MEG 0x100000
+
+# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+# NOTE: While we would ideally place the header in say __TEXT,__const we
+# cannot do that and have GRUB find it because GRUB only searches the first
+# 8k of the binary.  Since __TEXT,__const follows __TEXT,__text (the code
+# section) and since the code is well over 8k long, it doesn't work.
+.align 2, 0x90 # Make sure we're on a 4-byte boundary.  Required by Multiboot.
+_multiboot_header:
+    # magic (NOTE: this shows up as 02b0 ad1b in a hex dump)
+    .long   MULTIBOOT_HEADER_MAGIC
+    # flags
+    .long   MULTIBOOT_HEADER_FLAGS
+    # checksum
+    .long   -(MULTIBOOT_HEADER_MAGIC + MULTIBOOT_HEADER_FLAGS)
+    # header_addr
+    .long   (_multiboot_header + OFFSET_1MEG)
+    # load_addr
+    .long   (boot2 + OFFSET_1MEG)
+    # load_end_addr # Tell multiboot to load the whole file
+    .long   0 
+    # bss_end_addr # boot() will zero its own bss
+    .long   0
+    # entry_addr
+    .long   (_multiboot_entry + OFFSET_1MEG)
+
+# Stick a couple of nop here so that we hopefully make disassemblers realize we have instructions again
+    nop
+    nop
+    nop
+.align 3, 0x90 # Align to 8 byte boundary which should be enough nops
+
+# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+_multiboot_entry:
+    # First thing's first, let's get ourselves a usable GDT.
+    # Multiboot specifically says that GDT is not to be considered valid
+    # because for all we know the loader could have erased the memory where
+    # the GDT was located.  Even if it doesn't, it's very likely that we'll
+    # clobber it when we move ourselves into low memory.
+
+    # We have a GDT at the _Gdt symbol location which is defined in
+    # i386/libsaio/table.c.  Like all GDTs, entry 0 is unusable.  The first
+    # entry (0x08) is the one normally used by the booter.  However, it is
+    # specifically defined as byte-granularity to ensure the booter does not
+    # execute any code above 1 MB.  As mentioned above, we are above 1 MB so
+    # we can't use the 0x08 selector.  Fortunately, the booter specifies the
+    # 0x28 selector for the kernel init code using the typical 4K granularity
+    # and making all 32-bits of address space available.
+
+    # To load a GDT with the lgdt instruction we need to have the linear
+    # address of a GDTR structure.  The 16-bit boot code uses the _Gdtr
+    # variable which we will use later.  However, we are still in extended
+    # memory so even if we added 1 MB to _Gdtr the contents of it would
+    # still be pointing in low memory.  Therefore we have a _Gdtr_high
+    # which points to _Gdt + OFFSET_1MEG (see bottom of file)
+    # Notice that _Gdtr_high itself is located 1 MB above where the
+    # assembler/linker thinks it is.
+    lgdt    _Gdtr_high + OFFSET_1MEG
+
+    # Now that we have a GDT we want to first reload the CS register. We do
+    # that using a far jump to the desired selector with the desired offset.
+    # The desired offset in this case is exactly 1 MB higher than the
+    # assembler/linker thinks it is.  As mentioned above, we use the kernel
+    # init code selector instead of the boot code selector.
+    jmp     $0x28,$(Lpost_gdt_switch+OFFSET_1MEG)
+Lpost_gdt_switch:
+
+    # Now that we have the right code selector we also want the rest of the
+    # selectors to be correct.  We use the same selector (0x10) as the
+    # __real_to_prot function in libsaio/asm.s.  This is important as it
+    # means we won't need to do this again after the next GDT switch.
+
+    # We have to clobber one register because segment registers can only be
+    # loaded from GP registers.  Fortunately, only eax and ebx are provided
+    # by multiboot so we can clobber anything else.  We choose ecx.
+
+    movl    $0x10, %ecx
+    movl    %ecx,%ss
+    movl    %ecx,%ds
+    movl    %ecx,%es
+    movl    %ecx,%fs
+    movl    %ecx,%gs
+
+    # Initialize our stack pointer to the one normally used by the booter
+    # NOTE: This is somewhat dangerous considering it seems to be a de-facto
+    # Multiboot standard that the area below 1 MB is for the loader (e.g. GRUB)
+    # We may consider later putting the stack at + 1MB just like the code
+    # but we'd have to eventually get it below 1 MB because until we do we can't
+    # run any real-mode code (e.g. BIOS functions).
+    # Doing it this early we potentially run the risk that our multiboot_info
+    # pointer in ebx is already stuck somewhere in our stack segment
+    # Of course, the best method would be to have a couple of choices for
+    # stack space and put it wherever the multiboot_info is not.
+    movl    $ADDR32(STACK_SEG,STACK_OFS), %esp
+
+    # Some final notes about machine state:
+    
+    # We have no IDT and thus we leave interrupts disabled.  This is the same
+    # state that __real_to_prot leaves the machine in so it's not a problem.
+
+    # The A20 gate is enabled (it better be, we're above 1 MB)
+    # It is enabled as the first thing in boot() but it won't hurt for it
+    # to be enabled when it already is.
+
+    # Unlike when booting from real mode, when booting from Multiboot we have
+    # no stack to begin with.  This means that __switch_stack must never be
+    # called because it is preloaded with STACK_SEG,STACK_OFS which is where
+    # we already are.  Were it to be called it would effectively reset to the
+    # top of the stack which would not be good.
+    # We might think about adding a couple of instructions here to change
+    # its default values to something that could be used if necessary.
+
+    # At this point we're good enough to run C code.  I am no assembler guru
+    # so we won't be returning from it.
+    pushl   %ebx
+    pushl   %eax
+    call    _multiboot_to_boot # NOTE: near relative call, so we stay in high mem
+    # NORETURN
+
+    # NOTE: Once we get in to C, we should never return
+    # We let the C code take care of doing a chain boot which right now
+    # means to print an error message and restart the booter
+
+Lhltloop:
+    hlt     # This causes Parallels to power off although a normal PC will just hang
+    jmp Lhltloop
+
+# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+# _continue_at_low_address does some trickery to get the caller running from the low address with the right selector
+    .globl _continue_at_low_address
+    .align 2, 0x90
+_continue_at_low_address:
+    # Our stack frame has been set up with the return address on top
+    # First, fix that to be 1 MB lower
+    subl    $OFFSET_1MEG, (%esp)
+    # Now load the proper low-memory GDTR from the low-memory location which
+    # will cause the low-memory GDT to be used.
+    lgdt    _Gdtr
+    # Now jump to GDT selector 8 using the low address of this function
+    # This finally puts us in low memory in the right selector (0x08)
+    jmpl $0x08,$L_continue_at_low_address_next
+L_continue_at_low_address_next:
+    # We don't need to set ss,ds,es,fs, or gs because they are already 0x10
+    # and the old GDT had the same information for selector 0x10 as the new
+    # one does.
+    # Since we've already fixed our return pointer, simply return
+    # Note that our caller must fix his return pointer as well and that his
+    # caller must fix his return pointer and so on and so forth.
+    ret
+
+# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+# _jump_to_chainbooter sets up dl, switches from protected to real mode, and
+# jumps to 0:7C00.  Unlike the usual code, the stack is not switched since
+# there is no stack to switch to.
+    .globl _jump_to_chainbooter
+_jump_to_chainbooter:
+    # TODO: Take segment/offset arguments and put them in ES:SI?
+
+    xorl    %edx, %edx
+    movb    _chainbootdev, %dl  # Setup DL with the BIOS device number
+
+    call    __prot_to_real      # Back to real mode.
+
+    # TODO: Set SS:SP to something reasonable?  For instance, Microsoft MBR
+    # code starts out by setting up the stack at 0:7c00 for itself and leaves
+    # that intact.  Thus the stack by default will grow down from the code
+    # entrypoint.  On the other hand, our own boot0 sets up the stack at
+    # 0:fff0 and it seems that most boot code doesn't care and simply sets
+    # SS:SP itself as one of the first things it does.
+
+    data32
+    ljmp    $0, $0x7c00         # Jump to boot code already in memory
+
+# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+# _cause_crash jumps to offset 0 of a selector we know is not in our GDT
+# This causes Parallels to output all sorts of nice debugging information
+# We aren't using it right now so it's in an if 0 block.
+#if 0
+    .globl _cause_crash
+    .align 2, 0x90
+_cause_crash:
+    # Cause a crash, there is no GDT selector f0
+    jmp     $0xf0,$0
+    hlt
+    jmp _cause_crash
+#endif
+
+# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
+# _Gdtr_high is a pointer to the extended-memory loaded _Gdt
+# See the comments above as to why we have OFFSET_1MEG.
+    .data
+    .align 2, 0x90
+_Gdtr_high:
+    .word GDTLIMIT
+    .long vtop(_Gdt + OFFSET_1MEG)
+
Index: i386/boot2/boot.h
===================================================================
--- i386/boot2/boot.h	(.../vendor/132)	(revision 146)
+++ i386/boot2/boot.h	(.../branches/public)	(revision 146)
@@ -92,6 +92,9 @@
     kBootModeQuiet  = 4
 };
 
+extern void initialize_runtime();
+extern void common_boot(int biosdev);
+
 /*
  * graphics.c
  */
@@ -126,11 +129,19 @@
 extern long LoadDrivers(char * dirSpec);
 extern long DecodeKernel(void *binary, entry_t *rentry, char **raddr, int *rsize);
 
+typedef long (*FileLoadDrivers_t)(char *dirSpec, long plugin);
+/*!
+    Hookable function pointer called during the driver loading phase that
+    allows other code to cause additional drivers to be loaded.
+ */
+extern long (*LoadExtraDrivers_p)(FileLoadDrivers_t FileLoadDrivers_p);
+
 /*
  * options.c
  */
 extern int  getBootOptions(BOOL firstRun);
 extern int  processBootOptions();
+extern int selectAlternateBootDevice(int bootdevice);
 
 /*
  * lzss.c
Index: i386/boot2/drivers.c
===================================================================
--- i386/boot2/drivers.c	(.../vendor/132)	(revision 146)
+++ i386/boot2/drivers.c	(.../branches/public)	(revision 146)
@@ -76,6 +76,8 @@
   kCFBundleType3
 };
 
+long (*LoadExtraDrivers_p)(FileLoadDrivers_t FileLoadDrivers_p);
+
 static unsigned long Alder32( unsigned char * buffer, long length );
 
 static long FileLoadDrivers(char *dirSpec, long plugin);
@@ -157,6 +159,15 @@
     if ( InitDriverSupport() != 0 )
         return 0;
 
+    // Load extra drivers if a hook has been installed.
+    if (LoadExtraDrivers_p != NULL)
+    {
+        long ret = (*LoadExtraDrivers_p)(&FileLoadDrivers);
+        if(ret != 0)
+            return ret;
+    }
+    
+
     if ( gBootFileType == kNetworkDeviceType )
     {
         if (NetLoadDrivers(dirSpec) != 0) {
Index: i386/boot2/mboot.c
===================================================================
--- i386/boot2/mboot.c	(.../vendor/132)	(revision 0)
+++ i386/boot2/mboot.c	(.../branches/public)	(revision 146)
@@ -0,0 +1,476 @@
+/*
+    File added by David F. Elliott <dfe@cox.net> on 2007/06/26
+*/
+
+#include "libsaio.h"
+#include "boot.h"
+#include "bootstruct.h"
+
+#include "mboot.h"
+
+// Global multiboot info, if using multiboot.
+static struct multiboot_info *gMI;
+
+extern void continue_at_low_address(void);
+
+// prototype hi_multiboot and keep its implementation below multiboot_to_boot
+// to ensure that it doesn't get inlined by the compiler
+// We don't want it inlined because we specifically want the stack frame
+// pointer to be as high as possible and the hi_multiboot function
+// copies multiboot_info onto its stack.
+uint32_t hi_multiboot(int multiboot_magic, struct multiboot_info *mi_orig);
+// prototype dochainload for the same reason.
+void dochainload();
+
+#define OFFSET_1MEG 0x100000
+#define BAD_BOOT_DEVICE 0xffffffff
+
+// This assumes that the address of the first argument to the function will
+// be exactly 4 bytes above the address of the return address.
+// It is intended to be used as an lvalue with a statement like this -= OFFSET_1MEG;
+#define RETURN_ADDRESS_USING_FIRST_ARG(arg) \
+    (*(uint32_t*)((char*)&(arg) - 4))
+
+#define FIX_RETURN_ADDRESS_USING_FIRST_ARG(arg) \
+    RETURN_ADDRESS_USING_FIRST_ARG(arg) -= OFFSET_1MEG
+
+extern void jump_to_chainbooter();
+extern unsigned char chainbootdev;
+extern unsigned char chainbootflag;
+
+void chainLoad();
+void waitThenReload();
+
+static int multibootRamdiskReadBytes( int biosdev, unsigned int blkno,
+                      unsigned int byteoff,
+                      unsigned int byteCount, void * buffer );
+static int multiboot_get_ramdisk_info(int biosdev, struct driveInfo *dip);
+static long multiboot_LoadExtraDrivers(FileLoadDrivers_t FileLoadDrivers_p);
+
+// Starts off in the multiboot context 1 MB high but eventually gets into low memory
+// and winds up with a bootdevice in eax which is all that boot() wants
+// This lets the stack pointer remain very high.
+// If we were to call boot directly from multiboot then the whole multiboot_info
+// would be on the stack which would possibly be using way too much stack.
+void multiboot_to_boot(int multiboot_magic, struct multiboot_info *mi_orig)
+{
+    uint32_t bootdevice = hi_multiboot(multiboot_magic, mi_orig);
+    if(bootdevice != BAD_BOOT_DEVICE)
+    {
+        // boot only returns to do a chain load.
+        for(;;)
+        {   // NOTE: boot only uses the last byte (the drive number)
+            common_boot(bootdevice);
+            if(chainbootflag)
+                chainLoad();
+            else
+                waitThenReload();
+        }
+    }
+    // Avoid returning to high-memory address which isn't valid in the segment
+    // we are now in.
+    // Calling sleep() ensures the user ought to be able to use Ctrl+Alt+Del
+    // because the BIOS will have interrupts on.
+    for(;;)
+        sleep(10);
+    // NOTE: *IF* we needed to return we'd have to fix up our return address to
+    // be in low memory using the same trick as below.
+    // However, there doesn't seem to be any point in returning to assembly
+    // particularly when the remaining code merely halts the processor.
+}
+
+void chainLoad()
+{
+    /*  TODO: We ought to load the appropriate partition table, for example
+        the MBR if booting a primary partition or the particular extended
+        partition table if booting a logical drive.  For example, the
+        regular MS MBR booter will relocate itself (e.g. the MBR) from
+        0:7C00 to 0:0600 and will use SI as the offset when reading
+        the partition data from itself.  Thus when it jumps to the partition
+        boot sector, SI will be 0x600 + 446 + i<<4 where i is the partition
+        table index.
+    
+        On the other hand, our code for the non-Multiboot case doesn't do
+        this either, although GRUB does.
+     */
+
+    const unsigned char *bootcode = (const unsigned char*)0x7c00;
+    if(bootcode[0x1fe] == 0x55 && bootcode[0x1ff] == 0xaa)
+    {
+        printf("Calling chainbooter\n");
+        jump_to_chainbooter();
+        /* NORETURN */
+    }
+    else
+    {
+        printf("Bad chain boot sector magic: %02x%02x\n", bootcode[0x1fe], bootcode[0x1ff]);
+    }
+}
+
+void waitThenReload()
+{
+    /* FIXME: Ctrl+Alt+Del does not work under Boot Camp */
+    printf("Darwin booter exited for some reason.\n");
+    printf("Please reboot (Ctrl+Alt+Del) your machine.\n");
+    printf("Restarting Darwin booter in 5 seconds...");
+    sleep(1);
+    printf("4...");
+    sleep(1);
+    printf("3...");
+    sleep(1);
+    printf("2...");
+    sleep(1);
+    printf("1...");
+    sleep(1);
+    printf("0\n");
+}
+
+// Declare boot2_sym as an opaque struct so it can't be converted to a pointer
+// i.e. ensure the idiot programmer (me) makes sure to use address-of
+// Technically it's a function but it's real mode code and we sure don't
+// want to call it under any circumstances.
+extern struct {} boot2_sym asm("boot2");
+
+// prototype multiboot and keep its implementation below hi_multiboot to
+// ensure that it doesn't get inlined by the compiler
+static inline uint32_t multiboot(int multiboot_magic, struct multiboot_info *mi);
+
+
+/*!
+    Returns a pointer to the first safe address we can use for stowing the multiboot info.
+    This might actually be a bit pedantic because mboot.c32 and GRUB both stow the multiboot
+    info in low memory meaning that the >= 128 MB location we choose is plenty high enough.
+ */
+void *determine_safe_hi_addr(int multiboot_magic, struct multiboot_info *mi_orig)
+{
+    // hi_addr must be at least up in 128MB+ space so it doesn't get clobbered
+    void *hi_addr = (void*)PREBOOT_DATA;
+
+    // Fail if the magic isn't correct.  We'll complain later.
+    if(multiboot_magic != MULTIBOOT_INFO_MAGIC)
+        return NULL;
+    // Make sure the command-line isn't in high memory.
+    if(mi_orig->mi_flags & MULTIBOOT_INFO_HAS_CMDLINE)
+    {
+        char *end = mi_orig->mi_cmdline;
+        if(end != NULL)
+        {
+            for(; *end != '\0'; ++end)
+                ;
+            ++end;
+            if( (void*)end > hi_addr)
+                hi_addr = end;
+        }
+    }
+    // Make sure the module information isn't in high memory
+    if(mi_orig->mi_flags & MULTIBOOT_INFO_HAS_MODS)
+    {
+        struct multiboot_module *modules = (void*)mi_orig->mi_mods_addr;
+        int i;
+        for(i=0; i < mi_orig->mi_mods_count; ++i)
+        {
+            // make sure the multiboot_module struct itself won't get clobbered
+            void *modinfo_end = modules+i+1;
+            if(modinfo_end > hi_addr)
+                hi_addr = modinfo_end;
+            // make sure the module itself won't get clobbered
+            modinfo_end = (void*)modules[i].mm_mod_end;
+            if(modinfo_end > hi_addr)
+                hi_addr = modinfo_end;
+            // make sure the module string doesn't get clobbered
+            char *end = modules[i].mm_string;
+            for(; *end != '\0'; ++end)
+                ;
+            ++end;
+            modinfo_end = end;
+            if(modinfo_end > hi_addr)
+                hi_addr = modinfo_end;
+        }
+    }
+    // TODO: Copy syms (never needed), mmap, drives, config table, loader name, apm table, VBE info
+
+    // Round up to page size
+    hi_addr = (void*)(((uint32_t)hi_addr + 0xfff) & ~(uint32_t)0xfff);
+    return hi_addr;
+}
+
+/*!
+    Like malloc but with a preceding input/output parameter which points to the next available
+    location for data.  The original value of *hi_addr is returned and *hi_addr is incremented
+    by size bytes.
+ */
+void * _hi_malloc(void **hi_addr, size_t size)
+{
+    void *ret = *hi_addr;
+    *hi_addr += size;
+    return ret;
+}
+
+/*!
+    Like strdup but with a preceding input/output parameter.  The original value of *hi_addr is
+    returned and *hi_addr is incremented by the number of bytes necessary to complete the string
+    copy including its NUL terminator.
+ */
+char * _hi_strdup(void **hi_addr, char *src)
+{
+    char *dstStart;
+    char *dst = dstStart = *hi_addr;
+    for(; *src != '\0'; ++src, ++dst, ++(*hi_addr))
+        *dst = *src;
+    *dst = '\0';
+    ++(*hi_addr);
+    return dstStart;
+}
+
+// Convenience macros
+#define hi_malloc(size) _hi_malloc(&hi_addr, (size))
+#define hi_strdup(src) _hi_strdup(&hi_addr, (src))
+
+/*!
+    Copies the Multiboot info and any associated data (e.g. various strings and any multiboot modules)
+    up to very high RAM (above 128 MB) to ensure it doesn't get clobbered by the booter.
+ */
+struct multiboot_info * copyMultibootInfo(int multiboot_magic, struct multiboot_info *mi_orig)
+{
+    void *hi_addr = determine_safe_hi_addr(multiboot_magic, mi_orig);
+    if(hi_addr == NULL)
+        return NULL;
+
+    struct multiboot_info *mi_copy = hi_malloc(sizeof(*mi_copy));
+    memcpy(mi_copy, mi_orig, sizeof(*mi_copy));
+    
+    // Copy the command line
+    if(mi_orig->mi_flags & MULTIBOOT_INFO_HAS_CMDLINE)
+    {
+        mi_copy->mi_cmdline = hi_strdup(mi_orig->mi_cmdline);
+    }
+    // Copy the loader name
+    if(mi_orig->mi_flags & MULTIBOOT_INFO_HAS_LOADER_NAME)
+    {
+        mi_copy->mi_loader_name = hi_strdup(mi_orig->mi_loader_name);
+    }
+    // Copy the module info
+    if(mi_orig->mi_flags & MULTIBOOT_INFO_HAS_MODS)
+    {
+        struct multiboot_module *dst_modules = hi_malloc(sizeof(*dst_modules)*mi_orig->mi_mods_count);
+        struct multiboot_module *src_modules = (void*)mi_orig->mi_mods_addr;
+        mi_copy->mi_mods_addr = (uint32_t)dst_modules;
+
+        // Copy all of the module info plus the actual module into high memory
+        int i;
+        for(i=0; i < mi_orig->mi_mods_count; ++i)
+        {
+            // Assume mod_end is 1 past the actual end (i.e. it is start + size, not really end (i.e. start + size - 1))
+            // This is what GRUB and mboot.c32 do although the spec is unclear on this.
+            uint32_t mod_length = src_modules[i].mm_mod_end - src_modules[i].mm_mod_start;
+
+            dst_modules[i].mm_mod_start = (uint32_t)hi_malloc(mod_length);
+            dst_modules[i].mm_mod_end = (uint32_t)dst_modules[i].mm_mod_start + mod_length;
+            memcpy((char*)dst_modules[i].mm_mod_start, (char*)src_modules[i].mm_mod_start, mod_length);
+            
+            dst_modules[i].mm_string = hi_strdup(src_modules[i].mm_string);
+            dst_modules[i].mm_reserved = src_modules[i].mm_reserved;
+        }
+    }
+    // Make sure that only stuff that didn't need to be copied or that we did deep copy is indicated in the copied struct.
+    mi_copy->mi_flags &= MULTIBOOT_INFO_HAS_MEMORY | MULTIBOOT_INFO_HAS_BOOT_DEVICE | MULTIBOOT_INFO_HAS_CMDLINE | MULTIBOOT_INFO_HAS_LOADER_NAME | MULTIBOOT_INFO_HAS_MODS;
+
+    return mi_copy;
+}
+
+// When we enter, we're actually 1 MB high.
+// Fortunately, memcpy is position independent, and it's all we need
+uint32_t hi_multiboot(int multiboot_magic, struct multiboot_info *mi_orig)
+{
+    // Copy the multiboot info out of the way.
+    // We can't bitch about the magic yet because printf won't work
+    // because it contains an absolute location of putchar which
+    // contains absolute locations to other things which eventually
+    // makes a BIOS call from real mode which of course won't work
+    // because we're stuck in extended memory at this point.
+    struct multiboot_info *mi_p = copyMultibootInfo(multiboot_magic, mi_orig);
+
+    // Get us in to low memory so we can run everything
+
+    // We cannot possibly be more than 64k and copying extra won't really hurt anything
+    // We use the address of the assembly entrypoint to get our starting location.
+    memcpy(&boot2_sym, (char*)&boot2_sym + OFFSET_1MEG, 0x10000 /* 64k */);
+
+    // This is a little assembler routine that returns to us in the correct selector
+    // instead of the kernel selector we're running in now and at the correct
+    // instruction pointer ( current minus 1 MB ).  It does not fix our return
+    // address nor does it fix the return address of our caller.
+    continue_at_low_address();
+
+    // Now fix our return address.
+    FIX_RETURN_ADDRESS_USING_FIRST_ARG(multiboot_magic);
+
+    // We can now do just about anything, including return to our caller correctly.
+    // However, our caller must fix his return address if he wishes to return to
+    // his caller and so on and so forth.
+
+    /*  Zero the BSS and initialize malloc */
+    initialize_runtime();
+
+    gMI = mi_p;
+
+    /*  Set up a temporary bootArgs so we can call console output routines
+        like printf that check the v_display.  Note that we purposefully
+        do not initialize anything else at this early stage.
+
+        We are reasonably sure we're already in text mode if GRUB booted us.
+        This is the same assumption that initKernBootStruct makes.
+        We could check the multiboot info I guess, but why bother?
+     */
+    boot_args temporaryBootArgsData;
+    bzero(&temporaryBootArgsData, sizeof(boot_args));
+    bootArgs = &temporaryBootArgsData;
+    bootArgs->Video.v_display = VGA_TEXT_MODE;
+
+    // Install ramdisk and extra driver hooks
+    p_get_ramdisk_info = &multiboot_get_ramdisk_info;
+    p_ramdiskReadBytes = &multibootRamdiskReadBytes;
+    LoadExtraDrivers_p = &multiboot_LoadExtraDrivers;
+
+    // Since we call multiboot ourselves, its return address will be correct.
+    // That is unless it's inlined in which case it does not matter.
+    uint32_t bootdevice = multiboot(multiboot_magic, mi_p);
+    // We're about to exit and temporaryBootArgs will no longer be valid
+    bootArgs = NULL;
+    return bootdevice;
+}
+
+enum {
+    kReturnKey     = 0x0d,
+    kEscapeKey     = 0x1b,
+    kBackspaceKey  = 0x08,
+    kASCIIKeyMask  = 0x7f
+};
+
+// This is the meat of our implementation.  It grabs the boot device from
+// the multiboot_info and returns it as is.  If it fails it returns
+// BAD_BOOT_DEVICE.  We can call an awful lot of libsa and libsaio but
+// we need to take care not to call anything that requires malloc because
+// it won't be initialized until boot() does it.
+static inline uint32_t multiboot(int multiboot_magic, struct multiboot_info *mi)
+{
+    if(multiboot_magic != MULTIBOOT_INFO_MAGIC)
+    {
+        printf("Wrong Multiboot magic\n");
+        sleep(2);
+        return BAD_BOOT_DEVICE;
+    }
+    printf("Multiboot info @0x%x\n", (uint32_t)mi);
+    if(mi->mi_flags & MULTIBOOT_INFO_HAS_LOADER_NAME)
+        printf("Loaded by %s\n", mi->mi_loader_name);
+
+    // Multiboot puts boot device in high byte
+    // Normal booter wants it in low byte
+    int bootdevice = mi->mi_boot_device_drive;
+
+    bool doSelectDevice = false;
+    if(mi->mi_flags & MULTIBOOT_INFO_HAS_BOOT_DEVICE)
+    {
+        printf("Boot device 0x%x\n", bootdevice);
+    }
+    else
+    {
+        printf("Multiboot info does not include chosen boot device\n");
+        doSelectDevice = true;
+        bootdevice = BAD_BOOT_DEVICE;
+    }
+    if(mi->mi_flags & MULTIBOOT_INFO_HAS_CMDLINE)
+    {
+        const char *val;
+        int size;
+        
+        if(getValueForBootKey(mi->mi_cmdline, "biosdev", &val, &size) != NO)
+        {
+            char *endptr;
+            int intVal = strtol(val, &endptr, 16 /* always hex */);
+            if(*val != '\0' && (*endptr == '\0' || *endptr == ' ' || *endptr == '\t'))
+            {
+                printf("Boot device overridden to %02x with biosdev=%s\n", intVal, val);
+                bootdevice = intVal;
+                doSelectDevice = false;
+            }
+            else
+                doSelectDevice = true;
+        }
+    }
+    if(doSelectDevice)
+    {
+        bootdevice = selectAlternateBootDevice(bootdevice);
+    }
+    if(bootdevice == BAD_BOOT_DEVICE)
+        sleep(2); // pause for a second before halting
+    return bootdevice;
+}
+
+///////////////////////////////////////////////////////////////////////////
+// Ramdisk and extra drivers code
+
+static int multibootRamdiskReadBytes( int biosdev, unsigned int blkno,
+                      unsigned int byteoff,
+                      unsigned int byteCount, void * buffer )
+{
+    int module_count = gMI->mi_mods_count;
+    struct multiboot_module *modules = (void*)gMI->mi_mods_addr;
+    if(biosdev < 0x100)
+        return -1;
+    if(biosdev >= (0x100 + module_count))
+        return -1;
+    struct multiboot_module *module = modules + (biosdev - 0x100);
+
+    void *p_initrd = (void*)module->mm_mod_start;
+    bcopy(p_initrd + blkno*512 + byteoff, buffer, byteCount);
+    return 0;
+}
+
+static int multiboot_get_ramdisk_info(int biosdev, struct driveInfo *dip)
+{
+    int module_count = gMI->mi_mods_count;
+    struct multiboot_module *modules = (void*)gMI->mi_mods_addr;
+    if(biosdev < 0x100)
+        return -1;
+    if(biosdev >= (0x100 + module_count))
+        return -1;
+    struct multiboot_module *module = modules + (biosdev - 0x100);
+    dip->biosdev = biosdev;
+    dip->uses_ebios = TRUE;
+    dip->di.params.phys_sectors = (module->mm_mod_end - module->mm_mod_start + 511) / 512;
+    dip->valid = TRUE;
+    return 0;
+}
+
+static long multiboot_LoadExtraDrivers(FileLoadDrivers_t FileLoadDrivers_p)
+{
+    char extensionsSpec[1024];
+    int ramdiskUnit;
+    for(ramdiskUnit = 0; ramdiskUnit < gMI->mi_mods_count; ++ramdiskUnit)
+    {
+        int partCount; // unused
+        BVRef ramdiskChain = diskScanBootVolumes(0x100 + ramdiskUnit, &partCount);
+        if(ramdiskChain == NULL)
+        {
+            verbose("Ramdisk contains no partitions\n");
+            continue;
+        }
+        for(; ramdiskChain != NULL; ramdiskChain = ramdiskChain->next)
+        {
+            sprintf(extensionsSpec, "rd(%d,%d)/Library/Application Support/DarwinBoot/Extra/", ramdiskUnit, ramdiskChain->part_no);
+            struct dirstuff *extradir = opendir(extensionsSpec);
+            closedir(extradir);
+            if(extradir != NULL)
+            {
+                int ret = FileLoadDrivers_p(extensionsSpec, 0 /* this is a kext root dir, not a kext with plugins */);
+                if(ret != 0)
+                {
+                    verbose("FileLoadDrivers failed on a ramdisk\n");
+                    return ret;
+                }
+            }
+        }
+    }
+    return 0;
+}
Index: i386/boot2/multiboot.h
===================================================================
--- i386/boot2/multiboot.h	(.../vendor/132)	(revision 0)
+++ i386/boot2/multiboot.h	(.../branches/public)	(revision 146)
@@ -0,0 +1,201 @@
+/*	$NetBSD: multiboot.h,v 1.4 2006/10/25 13:56:16 jmmv Exp $	*/
+
+/*-
+ * Copyright (c) 2005, 2006 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Julio M. Merino Vidal.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the NetBSD
+ *	Foundation, Inc. and its contributors.
+ * 4. Neither the name of The NetBSD Foundation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* Modified by David Elliott <dfe@cox.net> on 2007/06/27 
+   - Removed checks for KERNEL define
+   - Replaced _LOCORE def check with __ASSEMBLER__ def check
+   - Removed prototypes for C functions we don't have
+   - Replaced all paddr_t and vaddr_t types with uint32_t and a comment
+*/
+
+/* --------------------------------------------------------------------- */
+
+/*
+ * Multiboot header structure.
+ */
+#define MULTIBOOT_HEADER_MAGIC		0x1BADB002
+#define MULTIBOOT_HEADER_MODS_ALIGNED	0x00000001
+#define MULTIBOOT_HEADER_WANT_MEMORY	0x00000002
+#define MULTIBOOT_HEADER_HAS_VBE	0x00000004
+#define MULTIBOOT_HEADER_HAS_ADDR	0x00010000
+
+#if !defined(__ASSEMBLER__)
+struct multiboot_header {
+	uint32_t	mh_magic;
+	uint32_t	mh_flags;
+	uint32_t	mh_checksum;
+
+	/* Valid if mh_flags sets MULTIBOOT_HEADER_HAS_ADDR. */
+	uint32_t	mh_header_addr; /* paddr_t */
+	uint32_t	mh_load_addr; /* paddr_t */
+	uint32_t	mh_load_end_addr; /* paddr_t */
+	uint32_t	mh_bss_end_addr; /* paddr_t */
+	uint32_t	mh_entry_addr; /* paddr_t */
+
+	/* Valid if mh_flags sets MULTIBOOT_HEADER_HAS_VBE. */
+	uint32_t	mh_mode_type;
+	uint32_t	mh_width;
+	uint32_t	mh_height;
+	uint32_t	mh_depth;
+};
+#endif /* !defined(__ASSEMBLER__) */
+
+/*
+ * Symbols defined in locore.S.
+ */
+#if !defined(__ASSEMBLER__)
+extern struct multiboot_header *Multiboot_Header;
+#endif /* !defined(__ASSEMBLER__) */
+
+/* --------------------------------------------------------------------- */
+
+/*
+ * Multiboot information structure.
+ */
+#define MULTIBOOT_INFO_MAGIC		0x2BADB002
+#define MULTIBOOT_INFO_HAS_MEMORY	0x00000001
+#define MULTIBOOT_INFO_HAS_BOOT_DEVICE	0x00000002
+#define MULTIBOOT_INFO_HAS_CMDLINE	0x00000004
+#define MULTIBOOT_INFO_HAS_MODS		0x00000008
+#define MULTIBOOT_INFO_HAS_AOUT_SYMS	0x00000010
+#define MULTIBOOT_INFO_HAS_ELF_SYMS	0x00000020
+#define MULTIBOOT_INFO_HAS_MMAP		0x00000040
+#define MULTIBOOT_INFO_HAS_DRIVES	0x00000080
+#define MULTIBOOT_INFO_HAS_CONFIG_TABLE	0x00000100
+#define MULTIBOOT_INFO_HAS_LOADER_NAME	0x00000200
+#define MULTIBOOT_INFO_HAS_APM_TABLE	0x00000400
+#define MULTIBOOT_INFO_HAS_VBE		0x00000800
+
+#if !defined(__ASSEMBLER__)
+struct multiboot_info {
+	uint32_t	mi_flags;
+
+	/* Valid if mi_flags sets MULTIBOOT_INFO_HAS_MEMORY. */
+	uint32_t	mi_mem_lower;
+	uint32_t	mi_mem_upper;
+
+	/* Valid if mi_flags sets MULTIBOOT_INFO_HAS_BOOT_DEVICE. */
+	uint8_t		mi_boot_device_part3;
+	uint8_t		mi_boot_device_part2;
+	uint8_t		mi_boot_device_part1;
+	uint8_t		mi_boot_device_drive;
+
+	/* Valid if mi_flags sets MULTIBOOT_INFO_HAS_CMDLINE. */
+	char *		mi_cmdline;
+
+	/* Valid if mi_flags sets MULTIBOOT_INFO_HAS_MODS. */
+	uint32_t	mi_mods_count;
+	uint32_t	mi_mods_addr; /* vaddr_t */
+
+	/* Valid if mi_flags sets MULTIBOOT_INFO_HAS_{AOUT,ELF}_SYMS. */
+	uint32_t	mi_elfshdr_num;
+	uint32_t	mi_elfshdr_size;
+	uint32_t	mi_elfshdr_addr; /* vaddr_t */
+	uint32_t	mi_elfshdr_shndx;
+
+	/* Valid if mi_flags sets MULTIBOOT_INFO_HAS_MMAP. */
+	uint32_t	mi_mmap_length;
+	uint32_t	mi_mmap_addr; /* vaddr_t */
+
+	/* Valid if mi_flags sets MULTIBOOT_INFO_HAS_DRIVES. */
+	uint32_t	mi_drives_length;
+	uint32_t	mi_drives_addr; /* vaddr_t */
+
+	/* Valid if mi_flags sets MULTIBOOT_INFO_HAS_CONFIG_TABLE. */
+	void *		unused_mi_config_table;
+
+	/* Valid if mi_flags sets MULTIBOOT_INFO_HAS_LOADER_NAME. */
+	char *		mi_loader_name;
+
+	/* Valid if mi_flags sets MULTIBOOT_INFO_HAS_APM. */
+	void *		unused_mi_apm_table;
+
+	/* Valid if mi_flags sets MULTIBOOT_INFO_HAS_VBE. */
+	void *		unused_mi_vbe_control_info;
+	void *		unused_mi_vbe_mode_info;
+	uint32_t	unused_mi_vbe_interface_seg; /* paddr_t */
+	uint32_t	unused_mi_vbe_interface_off; /* paddr_t */
+	uint32_t	unused_mi_vbe_interface_len;
+};
+
+/* --------------------------------------------------------------------- */
+
+struct multiboot_module {
+	uint32_t	mm_mod_start;
+	uint32_t	mm_mod_end;
+	char *		mm_string;
+	uint32_t	mm_reserved;
+};
+
+/*
+ * Drive information.  This describes an entry in the drives table as
+ * pointed to by mi_drives_addr.
+ */
+struct multiboot_drive {
+	uint32_t	md_length;
+	uint8_t		md_number;
+	uint8_t		md_mode;
+	uint16_t	md_cylinders;
+	uint8_t		md_heads;
+	uint8_t		md_sectors;
+
+	/* The variable-sized 'ports' field comes here, so this structure
+	 * can be longer. */
+};
+
+/* --------------------------------------------------------------------- */
+
+/*
+ * Memory mapping.  This describes an entry in the memory mappings table
+ * as pointed to by mi_mmap_addr.
+ *
+ * Be aware that mm_size specifies the size of all other fields *except*
+ * for mm_size.  In order to jump between two different entries, you
+ * have to count mm_size + 4 bytes.
+ */
+struct multiboot_mmap {
+	uint32_t	mm_size;
+	uint64_t	mm_base_addr;
+	uint64_t	mm_length;
+	uint32_t	mm_type;
+};
+
+#endif /* !defined(__ASSEMBLER__) */
+
+/* --------------------------------------------------------------------- */
+
Index: i386/boot2/mboot.h
===================================================================
--- i386/boot2/mboot.h	(.../vendor/132)	(revision 0)
+++ i386/boot2/mboot.h	(.../branches/public)	(revision 146)
@@ -0,0 +1,21 @@
+/* File added by David F. Elliott <dfe@cox.net> on 2007/06/27 */
+#include "multiboot.h"
+
+/*
+The following DWORD tells the loader what features we require of it.
+bit  0 set: Align modules on 4KB. We have no modules, we may not need this.
+bit  1 set: Provide info about memory. We probably don't need this either
+bit  2    : We might want this.  If so we need to tell the loader to stick
+              us in text mode.  We currently assume that the loader will put
+              us in text mode if we lack this because that is what GRUB does.
+bit 16 set: This is not ELF, use the multiboot_header fields.
+            We definitely need this flag.
+*/
+/* #define MULTIBOOT_HEADER_FLAGS 0x00010003 */
+
+#define MULTIBOOT_HEADER_FLAGS \
+    (MULTIBOOT_HEADER_HAS_ADDR|MULTIBOOT_HEADER_WANT_MEMORY|MULTIBOOT_HEADER_MODS_ALIGNED)
+
+#ifndef __ASSEMBLER__
+/* Put any desired prototypes or other C stuff here. */
+#endif
Index: i386/boot2/options.c
===================================================================
--- i386/boot2/options.c	(.../vendor/132)	(revision 146)
+++ i386/boot2/options.c	(.../branches/public)	(revision 146)
@@ -423,6 +423,7 @@
 }
 
 //==========================================================================
+extern void printFrequencyInfo();
 
 int
 getBootOptions(BOOL firstRun)
@@ -448,10 +449,19 @@
 
     if ( getIntForKey(kTimeoutKey, &timeout) == NO )
     {
+        /*  If there is no timeout key in the file use the default timeout
+            which is different for CDs vs. hard disks.  However, if not booting
+            a CD and no config file could be loaded set the timeout
+            to zero which causes the menu to display immediately.
+            This way, if no partitions can be found, that is the disk is unpartitioned
+            or simply cannot be read) then an empty menu is displayed.
+            If some partitions are found, for example a Windows partition, then
+            these will be displayed in the menu as foreign partitions.
+         */
         if ( isCDROM )
             timeout = kCDBootTimeout;
         else
-            timeout = kBootTimeout;
+            timeout = sysConfigValid?kBootTimeout:0;
     }
     if (timeout < 0) gBootMode |= kBootModeQuiet;
 
@@ -516,21 +526,29 @@
             optionKey = 0x4200;
         }
 
-        key = countdown(prompt, kMenuTopRow, timeout);
+        // If the timeout is zero then it must have been set above due to the
+        // early catch of F8 which means the user wants to set boot options
+        // which we ought to interpret as meaning he wants to boot the CD.
+        if(timeout != 0)
+            key = countdown(prompt, kMenuTopRow, timeout);
+        else
+            key = optionKey;
+
         if (cnt)
             free(prompt);
 
         clearScreenRows( kMenuTopRow, kMenuTopRow + 2 );
 
-        if (key == 0) {
+        if ( (key == 'h' || key == 'H') ) {
             // Boot from hard disk.
             // Scan the original device 0x80.
 
             BVRef hd_bvr = selectBootVolume(scanBootVolumes(0x80, 0));
-            if ( hd_bvr->flags & kBVFlagNativeBoot ) {
+            if ( hd_bvr != NULL && hd_bvr->flags & kBVFlagNativeBoot ) {
                 gBootVolume = hd_bvr;
+                setRootVolume(hd_bvr);
                 gBIOSDev = hd_bvr->biosdev;
-                initKernBootStruct( gBIOSDev );
+                // FIXME: This skips the boot menu.. do we want to do that?
                 goto done;
             }
         } else  {
@@ -622,6 +640,8 @@
                 {
                     if ( strcmp( gBootArgs, "?video" ) == 0 ) {
                         printVBEModeInfo();
+                    } else if ( strcmp( gBootArgs, "?clocks") == 0 ) {
+                        printFrequencyInfo();
                     } else if ( strcmp( gBootArgs, "?memory" ) == 0 ) {
                         printMemoryInfo();
                     } else {
@@ -635,6 +655,9 @@
                 break;
 
             case kEscapeKey:
+                // Apple behavior: Leave gBootVolume as is which causes the default choice to be booted
+                // New behavior: Clear gBootVolume to restart the loop.
+                gBootVolume = NULL;
                 clearBootArgs();
                 break;
 
@@ -762,13 +785,13 @@
             return 1;
         }
 
-        bootInfo->kernDev &= ~((B_UNITMASK << B_UNITSHIFT ) |
-                          (B_PARTITIONMASK << B_PARTITIONSHIFT));
+        setRootVolume(gBootVolume);
 
-        bootInfo->kernDev |= MAKEKERNDEV(    0,
- 		         /* unit */      BIOS_DEV_UNIT(gBootVolume),
-                        /* partition */ gBootVolume->part_no );
     }
+    // If no boot volume fail immediately because we're just going to fail
+    // trying to load the config file anyway.
+    else
+        return -1;
 
     // Load config table specified by the user, or use the default.
 
@@ -984,3 +1007,81 @@
         setActiveDisplayPage(0);
     }
 }
+
+static inline int isHexDigit(char ch)
+{
+    return ('0' <= ch && ch <= '9') || ('A' <= ch && ch <= 'F') || ('a' <= ch && ch <= 'f');
+}
+
+// This is a very simplistic prompting scheme that just grabs two hex characters
+// Eventually we need to do something more user-friendly like display a menu
+// based off of the Multiboot device list
+int selectAlternateBootDevice(int bootdevice)
+{
+    int digitsI = 0;
+    char digits[3] = {0,0,0};
+    
+    // We've already printed the current boot device so user knows what it is
+    printf("Typical boot devices are 80 (First HD), 81 (Second HD)\n");
+    printf("Enter two-digit hexadecimal boot device [%02x]: ", bootdevice);
+    int key = 0;
+    do {
+        key = getc();
+        switch(key & kASCIIKeyMask)
+        {
+        case kBackspaceKey:
+            if(digitsI > 0)
+            {
+                int x, y, t;
+                getCursorPositionAndType(&x, &y, &t);
+                // Assume x is not 0;
+                x--;
+                setCursorPosition(x,y,0); // back up one char
+                // Overwrite with space without moving cursor position
+                putca(' ', 0x07, 1);
+                digitsI--;
+            }
+            else
+            {
+                // TODO: Beep or something
+            }
+            break;
+        case kReturnKey:
+            if(1)
+            {
+                digits[digitsI] = '\0';
+                char *end;
+                int newbootdevice = strtol(digits, &end, 16);
+                if(end == digits && *end == '\0') // User entered empty string
+                {
+                    printf("\nUsing default boot device %x\n", bootdevice);
+                    key = 0;
+                }
+                else if(end != digits && *end == '\0')
+                {
+                    bootdevice = newbootdevice;
+                    printf("\n");
+                    key = 0; // We gots da boot device
+                }
+                else
+                {
+                    printf("\nCouldn't parse. try again: ");
+                    digitsI = 0;
+                }
+            }
+            break;
+        default:
+            if( isHexDigit(key & kASCIIKeyMask) && digitsI < 2 )
+            {
+                putc(key & kASCIIKeyMask);
+                digits[digitsI++] = key & kASCIIKeyMask;
+            }
+            else
+            {
+                // TODO: Beep or something
+            }
+        };
+    } while(key != 0);
+    return bootdevice;
+}
+
Index: i386/boot2/Makefile
===================================================================
--- i386/boot2/Makefile	(.../vendor/132)	(revision 146)
+++ i386/boot2/Makefile	(.../branches/public)	(revision 146)
@@ -8,7 +8,7 @@
 OPTIM = -Os -Oz
 CFLAGS	= $(RC_CFLAGS) $(OPTIM) $(MORECPP) -arch i386 -g -Wmost -Werror \
           -fno-builtin -DSAIO_INTERNAL_USER -static \
-	  -fomit-frame-pointer -mpreferred-stack-boundary=2 \
+	  $(OMIT_FRAME_POINTER_CFLAG) -mpreferred-stack-boundary=2 \
 	  -fno-align-functions -mno-sse2 -mfpmath=387
 DEFINES=
 CONFIG = hd
@@ -35,13 +35,13 @@
 
 # The ordering is important;
 # boot2.o must be first.
-OBJS = boot2.o boot.o graphics.o drivers.o prompt.o options.o lzss.o
+OBJS = boot2.o boot.o graphics.o drivers.o prompt.o options.o lzss.o mboot.o
 # button.o browser.o scrollbar.o == NOTYET	
 
 UTILDIR = ../util
 SFILES = boot2.s
-CFILES = boot.c graphics.c drivers.c prompt.c options.c
-HFILES = boot.h appleClut8.h appleboot.h
+CFILES = boot.c graphics.c drivers.c prompt.c options.c mboot.c
+HFILES = boot.h appleClut8.h appleboot.h mboot.h multiboot.h
 OTHERFILES = Makefile
 ALLSRC = $(FOREIGNSRC) $(FOREIGNBIN) $(SFILES) $(CFILES) \
 	$(HFILES) $(OTHERFILES)
Index: i386/libsa/libsa.h
===================================================================
--- i386/libsa/libsa.h	(.../vendor/132)	(revision 146)
+++ i386/libsa/libsa.h	(.../branches/public)	(revision 146)
@@ -44,6 +44,7 @@
 
 extern void * memset(void * dst, int c, size_t n);
 extern void * memcpy(void * dst, const void * src, size_t len);
+extern int    memcmp(const void * p1, const void * p2, int len);
 extern int    strcmp(const char * s1, const char * s2);
 extern int    strncmp(const char * s1, const char * s2, size_t n);
 extern char * strcpy(char * s1, const char * s2);
@@ -59,6 +60,8 @@
 extern int    strncasecmp(const char * s1, const char * s2, size_t n);
 #endif
 
+extern uint8_t checksum8( void * start, unsigned int length );
+
 /*
  * error.c
  */
Index: i386/libsa/efi_tables.h
===================================================================
--- i386/libsa/efi_tables.h	(.../vendor/132)	(revision 0)
+++ i386/libsa/efi_tables.h	(.../branches/public)	(revision 146)
@@ -0,0 +1,17 @@
+/*! @file       efi_tables.h
+    @abstract   Utility functions for dealing with EFI tables
+    Copyright 2007 David F. Elliott.  All rights reserved.
+ */
+#ifndef _LIBSA_EFI_TABLES_H__
+#define _LIBSA_EFI_TABLES_H__
+
+#include <pexpert/i386/efi.h>
+
+uint32_t
+crc32(uint32_t crc, const void *buf, size_t size);
+
+void efi_guid_unparse_upper(EFI_GUID const *pGuid, char *out);
+int efi_guid_is_null(EFI_GUID const *pGuid);
+int efi_guid_compare(EFI_GUID const *pG1, EFI_GUID const *pG2);
+
+#endif //ndef _LIBSA_EFI_TABLES_H__
Index: i386/libsa/string.c
===================================================================
--- i386/libsa/string.c	(.../vendor/132)	(revision 146)
+++ i386/libsa/string.c	(.../branches/public)	(revision 146)
@@ -117,7 +117,18 @@
 
 /*#endif*/
 
+/* NOTE: Moved from ntfs.c */
 int
+memcmp(const void *p1, const void *p2, int len)
+{
+    while (len--) {
+        if (*(const char*)(p1++) != *(const char*)(p2++))
+            return -1;
+    }
+    return 0;
+}
+
+int
 strcmp(const char * s1, const char * s2)
 {
 	while (*s1 && (*s1 == *s2)) {
@@ -216,3 +227,17 @@
 	return(n<0 ? 0 : tolower(*s1) - tolower(*--s2));
 }
 #endif
+
+/* COPYRIGHT NOTICE: checksum8 from AppleSMBIOS */
+uint8_t checksum8( void * start, unsigned int length )
+{
+    uint8_t   csum = 0;
+    uint8_t * cp = (uint8_t *) start;
+    unsigned int i;
+
+    for ( i = 0; i < length; i++)
+        csum += *cp++;
+
+    return csum;
+}
+
Index: i386/libsa/Makefile
===================================================================
--- i386/libsa/Makefile	(.../vendor/132)	(revision 146)
+++ i386/libsa/Makefile	(.../branches/public)	(revision 146)
@@ -8,7 +8,7 @@
 
 OPTIM = -Os -Oz
 CFLAGS	= $(RC_CFLAGS) $(OPTIM) $(MORECPP) -arch i386 -g -Wmost -Werror \
-	      -fno-builtin -static -fomit-frame-pointer \
+	      -fno-builtin -static $(OMIT_FRAME_POINTER_CFLAG) \
 	      -mpreferred-stack-boundary=2 -fno-align-functions \
 	      -mno-sse2 -mfpmath=387
 
@@ -27,12 +27,12 @@
 
 SA_OBJS = prf.o printf.o zalloc.o \
 	string.o strtol.o error.o \
-	setjmp.o qsort.o
+	setjmp.o qsort.o efi_tables.o
 
 SFILES = setjmp.s
 CFILES = prf.c printf.c zalloc.c \
 	string.c strtol.c error.c \
-	qsort.c
+	qsort.c efi_tables.c
 HFILES = memory.h
 EXPORTED_HFILES = libsa.h memory.h
 INSTALLED_SA_HFILES = libsa.h
Index: i386/libsa/efi_tables.c
===================================================================
--- i386/libsa/efi_tables.c	(.../vendor/132)	(revision 0)
+++ i386/libsa/efi_tables.c	(.../branches/public)	(revision 146)
@@ -0,0 +1,164 @@
+/*! @file       efi_tables.c
+    Copyright 2007 David F. Elliott.  All rights reserved.
+ */
+#include "libsa.h"
+#include "efi_tables.h"
+
+
+/*==========================================================================
+ * CRC32 implementation copied from xnu in turn copied from Gary S. Brown.
+ */
+
+/*-
+ *  COPYRIGHT (C) 1986 Gary S. Brown.  You may use this program, or
+ *  code or tables extracted from it, as desired without restriction.
+ *
+ *  First, the polynomial itself and its table of feedback terms.  The
+ *  polynomial is
+ *  X^32+X^26+X^23+X^22+X^16+X^12+X^11+X^10+X^8+X^7+X^5+X^4+X^2+X^1+X^0
+ *
+ *  Note that we take it "backwards" and put the highest-order term in
+ *  the lowest-order bit.  The X^32 term is "implied"; the LSB is the
+ *  X^31 term, etc.  The X^0 term (usually shown as "+1") results in
+ *  the MSB being 1
+ *
+ *  Note that the usual hardware shift register implementation, which
+ *  is what we're using (we're merely optimizing it by doing eight-bit
+ *  chunks at a time) shifts bits into the lowest-order term.  In our
+ *  implementation, that means shifting towards the right.  Why do we
+ *  do it this way?  Because the calculated CRC must be transmitted in
+ *  order from highest-order term to lowest-order term.  UARTs transmit
+ *  characters in order from LSB to MSB.  By storing the CRC this way
+ *  we hand it to the UART in the order low-byte to high-byte; the UART
+ *  sends each low-bit to hight-bit; and the result is transmission bit
+ *  by bit from highest- to lowest-order term without requiring any bit
+ *  shuffling on our part.  Reception works similarly
+ *
+ *  The feedback terms table consists of 256, 32-bit entries.  Notes
+ *
+ *      The table can be generated at runtime if desired; code to do so
+ *      is shown later.  It might not be obvious, but the feedback
+ *      terms simply represent the results of eight shift/xor opera
+ *      tions for all combinations of data and CRC register values
+ *
+ *      The values must be right-shifted by eight bits by the "updcrc
+ *      logic; the shift must be unsigned (bring in zeroes).  On some
+ *      hardware you could probably optimize the shift in assembler by
+ *      using byte-swap instructions
+ *      polynomial $edb88320
+ *
+ *
+ * CRC32 code derived from work by Gary S. Brown.
+ */
+
+static uint32_t crc32_tab[] = {
+	0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
+	0xe963a535, 0x9e6495a3,	0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
+	0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
+	0xf3b97148, 0x84be41de,	0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
+	0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec,	0x14015c4f, 0x63066cd9,
+	0xfa0f3d63, 0x8d080df5,	0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
+	0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,	0x35b5a8fa, 0x42b2986c,
+	0xdbbbc9d6, 0xacbcf940,	0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
+	0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
+	0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
+	0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,	0x76dc4190, 0x01db7106,
+	0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
+	0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
+	0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
+	0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
+	0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
+	0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
+	0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
+	0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
+	0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
+	0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
+	0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
+	0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
+	0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
+	0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
+	0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
+	0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
+	0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
+	0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
+	0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
+	0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
+	0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
+	0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
+	0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
+	0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
+	0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
+	0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
+	0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
+	0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
+	0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
+	0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
+	0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
+	0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
+};
+
+uint32_t
+crc32(uint32_t crc, const void *buf, size_t size)
+{
+	const uint8_t *p;
+
+	p = buf;
+	crc = crc ^ ~0U;
+
+	while (size--)
+		crc = crc32_tab[(crc ^ *p++) & 0xFF] ^ (crc >> 8);
+
+	return crc ^ ~0U;
+}
+
+
+/*==========================================================================
+ * Utility function to make a device tree string from an EFI_GUID
+ */
+
+void efi_guid_unparse_upper(EFI_GUID const *pGuid, char *out)
+{
+    sprintf(out, "%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X",
+        pGuid->Data1, /* - */
+        pGuid->Data2, /* - */
+        pGuid->Data3, /* - */
+        pGuid->Data4[0], pGuid->Data4[1], /* - */
+        pGuid->Data4[2], pGuid->Data4[3],
+        pGuid->Data4[4], pGuid->Data4[5],
+        pGuid->Data4[6], pGuid->Data4[7]);
+}
+
+int efi_guid_is_null(EFI_GUID const *pGuid)
+{
+    if(pGuid->Data1 == 0 && pGuid->Data2 == 0 && pGuid->Data3 == 0)
+    {
+        int i;
+        for(i=0; i<8; ++i)
+        {
+            if(pGuid->Data4[i] != 0)
+                return FALSE;
+        }
+        return TRUE;
+    }
+    return FALSE;
+}
+
+#define COMPARE_MEMBER_AND_RETURN_IF_NE(a,b,mem) \
+    if( ((a)->mem) < ((b)->mem) ) \
+        return -1; \
+    else if( ((a)->mem) > ((b)->mem) ) \
+        return 1;
+
+int efi_guid_compare(EFI_GUID const *pG1, EFI_GUID const *pG2)
+{
+    COMPARE_MEMBER_AND_RETURN_IF_NE(pG1, pG2, Data1);
+    COMPARE_MEMBER_AND_RETURN_IF_NE(pG1, pG2, Data2);
+    COMPARE_MEMBER_AND_RETURN_IF_NE(pG1, pG2, Data3);
+    int i;
+    for(i=0; i<8; ++i)
+    {
+        COMPARE_MEMBER_AND_RETURN_IF_NE(pG1, pG2, Data4[i]);
+    }
+    return 0;
+}
+
Index: i386/libsa/memory.h
===================================================================
--- i386/libsa/memory.h	(.../vendor/132)	(revision 146)
+++ i386/libsa/memory.h	(.../branches/public)	(revision 146)
@@ -27,14 +27,34 @@
 
 /* Memory addresses used by booter and friends */
 
-#define BASE_SEG          0x2000
+/*  DFE 2007-12-21: Changed BASE_SEG to be conditional
+    This allows boot1u and other planned first-stage booters to avoid
+    maintaining their own copies of asm.s and bios.s and instead
+    simply build the files from libsaio with the right preprocessor
+    definitions.
+
+    This affects BASE_ADDR and OFFSET16() thus obviating the need for
+    separate BASE1U_ADDR and OFFSET1U16() macros.
+
+    Be careful though as changing these values with preprocessor macros
+    obviously requires rebuilding the source files.  That means in particular
+    that libsaio.a is only suitable for boot2.
+ */
+#if defined(BASE_SEG)
+/* assume user knows what he's doing */
+#elif defined(BOOT1)
+# define BASE_SEG          BOOT1U_SEG
+#else
+# define BASE_SEG          BOOT2_SEG
+#endif
+
 #define STACK_SEG         0x5000
 #define STACK_OFS         0xFFF0      // stack pointer
 
 #define BOOT1U_SEG        0x1000
 #define BOOT1U_OFS        0x0200
 
-#define BOOT2_SEG         BASE_SEG
+#define BOOT2_SEG         0x2000
 #define BOOT2_OFS         0x0200      // 512 byte disk sector offset
 
 #define BIOS_ADDR         0x8000      // BIOS disk I/O buffer
@@ -54,9 +74,9 @@
 #define BOOTSTRUCT_LEN    0x0000F000
 
 #define BASE_ADDR         ADDR32(BASE_SEG, 0)
-#define BASE1U_ADDR       ADDR32(BOOT1U_SEG, 0)
 #define BOOT1U_ADDR       ADDR32(BOOT1U_SEG, BOOT1U_OFS)
 #define BOOT2_ADDR        ADDR32(BOOT2_SEG, BOOT2_OFS)
+// TODO: BOOT_ADDR ?
 
 #define HIB_ADDR          0x00040000    // special hibernation area
 #define HIB_LEN           0x00060000
@@ -73,6 +93,9 @@
 #define LOAD_ADDR         0x06800000   // 24M File load buffer
 #define LOAD_LEN          0x01800000
 
+// Location of data fed to boot2 by the prebooter
+#define PREBOOT_DATA      0x08000000
+
 #define TFTP_ADDR         LOAD_ADDR   // tftp download buffer
 #define TFTP_LEN          LOAD_LEN
 
@@ -89,10 +112,16 @@
  * Extract segment/offset from a linear address.
  */
 #define OFFSET16(addr)    ((addr) - BASE_ADDR)
-#define OFFSET1U16(addr)  ((addr) - BASE1U_ADDR)
 #define OFFSET(addr)      ((addr) & 0xFFFF)
 #define SEGMENT(addr)     (((addr) & 0xF0000) >> 4)
 
+/*  Extract segment/offset in normalized form so that the resulting far pointer
+    will point to something that is very unlikely to straddle a segment.
+    This is sometimes known as a "huge" pointer.
+ */
+#define NORMALIZED_OFFSET(addr)      ((addr) & 0x000F)
+#define NORMALIZED_SEGMENT(addr)     (((addr) & 0xFFFF0) >> 4)
+
 /*
  * We need a minimum of 32MB of system memory.
  */
Index: i386/boot1u/asm.s
===================================================================
--- i386/boot1u/asm.s	(.../vendor/132)	(revision 146)
+++ i386/boot1u/asm.s	(.../branches/public)	(revision 146)
@@ -1,447 +0,0 @@
-/*
- * Copyright (c) 1999-2003 Apple Computer, Inc. All rights reserved.
- *
- * @APPLE_LICENSE_HEADER_START@
- * 
- * Portions Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights
- * Reserved.  This file contains Original Code and/or Modifications of
- * Original Code as defined in and that are subject to the Apple Public
- * Source License Version 2.0 (the "License").  You may not use this file
- * except in compliance with the License.  Please obtain a copy of the
- * License at http://www.apple.com/publicsource and read it before using
- * this file.
- * 
- * The Original Code and all software distributed under the License are
- * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
- * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
- * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE OR NON- INFRINGEMENT.  Please see the
- * License for the specific language governing rights and limitations
- * under the License.
- * 
- * @APPLE_LICENSE_HEADER_END@
- */
-/* 
- * Mach Operating System
- * Copyright (c) 1990 Carnegie-Mellon University
- * Copyright (c) 1989 Carnegie-Mellon University
- * All rights reserved.  The CMU software License Agreement specifies
- * the terms and conditions for use and redistribution.
- */
-/*
- * HISTORY
- * $Log: asm.s,v $
- * Revision 1.3  2003/11/05 20:50:59  curtisg
- * Integrated 3069695,3331770,3370488,3371823
- *
- * Revision 1.2.14.1  2003/10/27 23:57:55  curtisg
- * Added printing of volume names, better handling of extended
- * partitions, and updated Apple license strings.
- * New chain booter should work better with foreign operating
- * systems.
- *
- * Revision 1.2  2003/04/08 20:28:27  curtisg
- * Merged PR-3073653, PR-3172003.
- *
- * Revision 1.1.2.1  2003/04/05 00:48:42  curtisg
- * Changes for 3073653.
- *
- * Revision 1.4  2002/10/02 00:06:18  curtisg
- * Integrating PR-3032510.
- *
- * Revision 1.3.6.1  2002/08/30 21:16:29  curtisg
- * KERNBOOTSTRUCT is going away in favor of KernelBootArgs_t in <pexpert/i386/boot.h>.
- *
- * Revision 1.3  2002/07/09 14:06:21  jliu
- * Merging changes from PR-2954224 branch in boot/i386.
- *
- * Revision 1.2.30.1  2002/07/05 16:24:51  jliu
- * Merged UFS/HFS/HFS+ filesystem support from BootX.
- * Moved boot2 load address due to increased size. boot0/boot1 also changed.
- * Updated boot graphics and CLUT.
- * Added support to chain load foreign booters.
- * Fixed param passing bug in network loader.
- * Misc cleanup in libsaio.
- *
- * Revision 1.2  2000/05/23 23:01:11  lindak
- * Merged PR-2309530 into Kodiak (liu i386 booter: does not support label-less
- * ufs partitions)
- *
- * Revision 1.1.1.2.4.1  2000/05/13 17:07:39  jliu
- * New boot0 (boot1 has been deprecated). Booter must now reside in its own partition, no disk label required.
- *
- * Revision 1.1.1.2  1999/08/04 21:16:57  wsanchez
- * Impoort of boot-66
- *
- * Revision 1.3  1999/08/04 21:12:12  wsanchez
- * Update APSL
- *
- * Revision 1.2  1999/03/25 05:48:30  wsanchez
- * Add APL.
- * Remove unused gzip code.
- * Remove unused Adobe fonts.
- *
- * Revision 1.1.1.1.66.2  1999/03/16 16:08:54  wsanchez
- * Substitute License
- *
- * Revision 1.1.1.1.66.1  1999/03/16 07:33:21  wsanchez
- * Add APL
- *
- * Revision 1.1.1.1  1997/12/05 21:57:57  wsanchez
- * Import of boot-25 (~mwatson)
- *
- * Revision 2.1.1.2  90//03//22  17:59:50  rvb
- *  Added _sp() => where is the stack at. [kupfer]
- * 
- * Revision 2.1.1.1  90//02//09  17:25:04  rvb
- *  Add Intel copyright
- *  [90//02//09            rvb]
- * 
- */
-
-
-//          INTEL CORPORATION PROPRIETARY INFORMATION
-//
-//  This software is supplied under the terms of a license  agreement or 
-//  nondisclosure agreement with Intel Corporation and may not be copied 
-//  nor disclosed except in accordance with the terms of that agreement.
-//
-//  Copyright 1988 Intel Corporation
-//  Copyright 1988, 1989 by Intel Corporation
-//
-
-#include <architecture/i386/asm_help.h>
-#include "memory.h"
-
-#define data32  .byte 0x66
-#define addr32  .byte 0x67
-
-    .file "asm.s"
-
-CR0_PE_ON  = 0x1
-CR0_PE_OFF = 0x7ffffffe
-
-STACK32_BASE = ADDR32(STACK_SEG, 0)
-STACK16_SEG  = STACK_SEG
-CODE32_BASE  = ADDR32(BOOT1U_SEG, 0)
-CODE16_SEG   = BOOT1U_SEG
-
-// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-// Pointer to 6-bytes in memory that contains the base address and the limit
-// (size of GDT table in bytes) of the GDT. The LGDT is the only instruction
-// that directly loads a linear address (not a segment relative address) and
-// a limit in protected mode.
-
-.globl _Gdtr
-    .data
-    .align 2, 0x90
-_Gdtr:
-    .word GDTLIMIT
-    .long vtop(_Gdt)
-
-// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-// Data area for __switch_stack.
-//
-save_sp: .long  STACK_OFS
-save_ss: .long  STACK_SEG
-
-    .text
-
-// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-// real_to_prot()
-//
-// Transfer from real mode to protected mode.
-// Preserves all registers except EAX.
-//
-LABEL(__real_to_prot)
-
-    // Interrupts are disabled in protected mode.
-
-    cli
-
-    // Load the Global Descriptor Table Register (GDTR).
-
-    addr32
-    data32
-    lgdt    OFFSET1U16(_Gdtr)
-
-    // Enter protected mode by setting the PE bit in CR0.
-
-    mov     %cr0, %eax
-    data32
-    or      $CR0_PE_ON, %eax
-    mov     %eax, %cr0
-
-    // Make intrasegment jump to flush the processor pipeline and
-    // reload CS register.
-
-    data32
-    ljmp    $0x08, $xprot
-
-xprot:
-    // we are in USE32 mode now
-    // set up the protected mode segment registers : DS, SS, ES, FS, GS
-
-    mov     $0x10, %eax
-    movw    %ax, %ds
-    movw    %ax, %ss
-    movw    %ax, %es
-    movw    %ax, %fs
-    movw    %ax, %gs
-
-    // Convert STACK_SEG:SP to 32-bit linear stack pointer.
-
-    movzwl  %sp, %eax
-    addl    $STACK32_BASE, %eax
-    movl    %eax, %esp
-
-    // Convert STACK_SEG:BP to 32-bit linear base pointer.
-
-    movzwl  %bp, %eax
-    addl    $STACK32_BASE, %eax
-    movl    %eax, %ebp
-
-    // Modify the caller's return address on the stack from
-    // segment offset to linear address.
-
-    popl    %eax
-    addl    $CODE32_BASE, %eax
-    pushl   %eax
-
-    ret
-
-// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-// prot_to_real()
-//
-// Transfer from protected mode to real mode.
-// Preserves all registers except EAX.
-// 
-LABEL(__prot_to_real)
-
-    // Set up segment registers appropriate for real mode.
-
-    movw    $0x30, %ax
-    movw    %ax, %ds
-    movw    %ax, %es
-    movw    %ax, %fs
-    movw    %ax, %gs
-    movw    %ax, %ss
-
-    ljmp    $0x18, $x16       // change to USE16 mode
-
-x16:
-    mov     %cr0, %eax        // clear the PE bit of CR0
-    data32
-    and     $CR0_PE_OFF, %eax
-    mov     %eax, %cr0
-
-    // make intersegment jmp to flush the processor pipeline
-    // and reload CS register
-
-    data32
-    ljmp    $CODE16_SEG, $xreal - CODE32_BASE
-
-xreal:
-    // we are in real mode now
-    // set up the real mode segment registers : DS, DS, ES, FS, GS
-
-    movw    %cs, %ax
-    movw    %ax, %ds
-    movw    %ax, %es
-    movw    %ax, %fs
-    movw    %ax, %gs
-
-    // load stack segment register SS.
-
-    data32
-    movl    $STACK16_SEG, %eax
-    movw    %ax, %ss
-
-    // clear top 16-bits of ESP and EBP.
-
-    data32
-    movzwl  %sp, %esp
-    data32
-    movzwl  %bp, %ebp
-
-    // Modify caller's return address on the stack
-    // from linear address to segment offset.
-
-    data32
-    popl    %eax
-    data32
-    movzwl  %ax, %eax
-    data32
-    pushl   %eax
-
-    // Reenable maskable interrupts.
-
-    sti
-
-    data32
-    ret
-
-// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-// halt()
-//
-LABEL(_halt)
-    hlt
-    jmp     _halt
-
-#if 0
-// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-// startprog(phyaddr, arg)
-// Start the program on protected mode where phyaddr is the entry point.
-// Passes arg to the program in %eax.
-//
-LABEL(_startprog)
-    push    %ebp
-    mov     %esp, %ebp
-
-    mov     0xc(%ebp), %eax  // argument to program
-    mov     0x8(%ebp), %ecx  // entry offset 
-    mov     $0x28, %ebx      // segment
-    push    %ebx
-    push    %ecx
-
-    // set up %ds and %es
-
-    mov     $0x20, %ebx
-    movw    %bx, %ds
-    movw    %bx, %es
-
-    lret
-#endif
-
-// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-// Returns the current stack pointer.
-//
-LABEL(__sp)
-    mov %esp, %eax
-    ret
-
-// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-// Returns the current frame pointer.
-//
-LABEL(__bp)
-    mov %ebp, %eax
-    ret
-
-// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-// switch_stack()
-//
-// Switches stack pointer between SS:SP and memory save_ss:save_sp.
-// Call this function from real mode only!!!
-//
-// AX, DI, and SI are clobbered.
-//
-LABEL(__switch_stack)
-    popl    %eax                # save return address
-    popl    %edi                # discard upper 16-bit
-
-    data32
-    addr32
-    movl    OFFSET1U16(save_ss), %esi   # new SS to SI
-
-    data32
-    addr32
-    movl    OFFSET1U16(save_sp), %edi   # new SP to DI
-
-    addr32
-    mov     %ss, OFFSET1U16(save_ss)    # save current SS to memory
-
-    data32
-    addr32
-    movl    %esp, OFFSET1U16(save_sp)   # save current SP to memory
-
-    cli
-    mov     %si, %ss            # switch stack
-    mov     %di, %sp
-    sti
-
-    pushl   %eax                # push IP of caller onto the new stack
-
-    xorl    %eax, %eax
-    xorl    %esi, %esi
-    xorl    %edi, %edi
-
-    ret
-
-#if 0
-// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-// loader()
-//
-// Issue a request to the network loader.
-//
-LABEL(_loader)
-    enter   $0, $0
-    pushal
-
-    #
-    # Pass a far pointer to the command structure
-    # to the INT call through DX:CX.
-    #
-    # The command code is in BX.
-    #
-
-    movw     8(%ebp), %bx       #  8[EBP] = command code
-    movw    12(%ebp), %cx       # 12[EBP] = command structure offset
-    movw    14(%ebp), %dx       # 14[EBP] = command structure segment
-
-    call    __prot_to_real      # Revert to real mode
-
-    ###### Real Mode Begin ######
-
-    data32
-    call    __switch_stack      # Switch to NBP stack
-
-    int     $0x2b               # Call NBP
-
-    data32
-    call    __switch_stack      # Restore stack
-
-    data32
-    call    __real_to_prot      # Back to protected mode
-
-    ###### Real Mode End ######
-
-    popal
-    leave
-    ret
-#endif
-
-#if 0
-// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-// pcpy(src, dst, cnt)
-//  where src is a virtual address and dst is a physical address
-//
-LABEL(_pcpy)
-    push    %ebp
-    mov     %esp, %ebp
-    push    %es
-    push    %esi
-    push    %edi
-    push    %ecx
-
-    cld
-
-    // set %es to point at the flat segment
-
-    mov     $0x20, %eax
-    movw    %ax , %es
-
-    mov     0x8(%ebp), %esi     // source
-    mov     0xc(%ebp), %edi     // destination
-    mov     0x10(%ebp), %ecx    // count
-
-    rep
-    movsb
-
-    pop     %ecx
-    pop     %edi
-    pop     %esi
-    pop     %es
-    pop     %ebp
-
-    ret
-#endif
Index: i386/boot1u/bios.s
===================================================================
--- i386/boot1u/bios.s	(.../vendor/132)	(revision 146)
+++ i386/boot1u/bios.s	(.../branches/public)	(revision 146)
@@ -1,133 +0,0 @@
-/*
- * Copyright (c) 1999-2003 Apple Computer, Inc. All rights reserved.
- *
- * @APPLE_LICENSE_HEADER_START@
- * 
- * Portions Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights
- * Reserved.  This file contains Original Code and/or Modifications of
- * Original Code as defined in and that are subject to the Apple Public
- * Source License Version 2.0 (the "License").  You may not use this file
- * except in compliance with the License.  Please obtain a copy of the
- * License at http://www.apple.com/publicsource and read it before using
- * this file.
- * 
- * The Original Code and all software distributed under the License are
- * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
- * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
- * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE OR NON- INFRINGEMENT.  Please see the
- * License for the specific language governing rights and limitations
- * under the License.
- * 
- * @APPLE_LICENSE_HEADER_END@
- */
-/*
- * Copyright 1993 NeXT Computer, Inc.
- * All rights reserved.
- *
- * Harness for calling real-mode BIOS functions.
- */
-
-#include <architecture/i386/asm_help.h>
-#include "memory.h"
-
-#define data32  .byte 0x66
-#define addr32  .byte 0x67
-
-#define O_INT   0
-#define O_EAX   4
-#define O_EBX   8
-#define O_ECX   12
-#define O_EDX   16
-#define O_EDI   20
-#define O_ESI   24
-#define O_EBP   28
-#define O_CS    32
-#define O_DS    34
-#define O_ES    36
-#define O_FLG   38
-
-.data
-    .lcomm save_eax,  4,2
-    .lcomm save_edx,  4,2
-    .lcomm save_es,   2,1
-    .lcomm save_flag, 2,1
-    .lcomm new_eax,   4,2
-    .lcomm new_edx,   4,2
-    .lcomm new_es,    2,1
-
-.text
-
-/*============================================================================
- * Call real-mode BIOS INT functions.
- *
- */
-LABEL(_bios)
-    enter   $0, $0
-    pushal
-
-    movl    8(%ebp), %edx       // address of save area
-    movb    O_INT(%edx), %al    // save int number
-    movb    %al, do_int+1
-
-    movl    O_EBX(%edx), %ebx
-    movl    O_ECX(%edx), %ecx
-    movl    O_EDI(%edx), %edi
-    movl    O_ESI(%edx), %esi
-    movl    O_EBP(%edx), %ebp
-    movl    %edx, save_edx
-    movl    O_EAX(%edx), %eax
-    movl    %eax, new_eax
-    movl    O_EDX(%edx), %eax
-    movl    %eax, new_edx
-    movw    O_ES(%edx),  %ax
-    movl    %ax, new_es
-
-    call    __prot_to_real
-
-    data32
-    addr32
-    mov     OFFSET1U16(new_eax), %eax
-    data32
-    addr32
-    mov     OFFSET1U16(new_edx), %edx
-    data32
-    addr32
-    mov     OFFSET1U16(new_es), %es
-
-do_int:
-    int     $0x00
-    pushf
-    data32
-    addr32
-    movl    %eax, OFFSET1U16(save_eax)
-    popl    %eax                         // actually pop %ax
-    addr32
-    movl    %eax, OFFSET1U16(save_flag)  // actually movw
-    mov     %es, %ax
-    addr32
-    movl    %eax, OFFSET1U16(save_es)    // actually movw
-    data32
-    call    __real_to_prot
-
-    movl    %edx, new_edx       // save new edx before clobbering
-    movl    save_edx, %edx
-    movl    new_edx, %eax       // now move it into buffer
-    movl    %eax, O_EDX(%edx)
-    movl    save_eax, %eax
-    movl    %eax, O_EAX(%edx)
-    movw    save_es, %ax
-    movw    %ax, O_ES(%edx)
-    movw    save_flag, %ax
-    movw    %ax, O_FLG(%edx)
-    movl    %ebx, O_EBX(%edx)
-    movl    %ecx, O_ECX(%edx)
-    movl    %edi, O_EDI(%edx)
-    movl    %esi, O_ESI(%edx)
-    movl    %ebp, O_EBP(%edx)
-
-    popal
-    leave
-
-    ret
-
Index: i386/boot1u/Makefile
===================================================================
--- i386/boot1u/Makefile	(.../vendor/132)	(revision 146)
+++ i386/boot1u/Makefile	(.../branches/public)	(revision 146)
@@ -2,8 +2,10 @@
 include ../MakePaths.dir
 
 OPTIM = -Os -Oz
+# Define BOOT1 even when preprocessing assembler
+CPPFLAGS = -DBOOT1
 CFLAGS	= $(RC_CFLAGS) $(OPTIM) $(MORECPP) -arch i386 -g -Wmost -Werror \
-          -fno-builtin -DSAIO_INTERNAL_USER -DBOOT1 -static \
+          -fno-builtin -DSAIO_INTERNAL_USER -static \
 	  -fomit-frame-pointer -mpreferred-stack-boundary=2 \
 	  -fno-align-functions -mno-sse2 -mfpmath=387
 DEFINES=
@@ -27,6 +29,8 @@
 
 INSTALLDIR = $(DSTROOT)/usr/standalone/i386
 VPATH = $(SYMROOT):$(OBJROOT)
+vpath %.s ../libsaio
+vpath %   $(SYMROOT)
 vpath %.c ../libsaio
 vpath %   $(SYMROOT)
 vpath %.h ../libsaio
